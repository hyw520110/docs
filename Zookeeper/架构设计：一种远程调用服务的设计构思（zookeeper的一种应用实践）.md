<p>出处：<a href="http://www.cnblogs.com/sharpxiajun/p/3297852.html" target="_blank">http://www.cnblogs.com/sharpxiajun/p/3297852.html</a> </p>
<p><br></p>
<p><strong><span style="font-family:'宋体';">大型网站架构交流</span></strong><strong>QQ</strong><strong><span style="font-family:'宋体';">群：</span></strong><strong>466097527 </strong><strong><span style="font-family:'宋体';">每周技术分享</span></strong><strong> </strong><strong><span style="font-family:'宋体';">经典电子书分享</span></strong><strong> </strong><strong><span style="font-family:'宋体';">欢迎加群</span></strong></p>
<p><span style="font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;background-color:rgb(238,238,238);"><br></span></p>
<p><span style="font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;background-color:rgb(238,238,238);">在深入学习zookeeper我想先给大家介绍一个和zookeeper相关的应用实例，我把这个实例命名为远程调用服务。通过对这种应用实例的描述，我们会对zookeeper应用场景会有深入的了解。</span><br></p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　远程调用是系统与系统之间的通信机制，它的另一种理解就是进程间的通信。做分布式系统的开发，远程调用技术是其核心技术。远程调用技术可以将一组计算机系统形成一个网络系统，对外提供整体服务，那么这一群的计算机系统就构成了一个更大型，性能更高的计算机系统。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　我在前面的博客里介绍了一种分布式网站的架构设计，其中就有一个使用netty技术编写的组件作为前端系统和服务端系统通信的媒介。在一个大型的互联网公司里会有很多这样的网站系统，如果每一个网站都像我博客里所论述的进行开发，那么对于系统通信维护和管理，以及每个系统网络资源的分配管理就会造成一定的问题，对于这样的问题，我举个例子可能大家会更明白些，比如一个互联网公司有数个对外提供服务的网站，有的网站访问量很大，有的相对较小，但是公司的宽带资源是有限的，那么我们就希望动态的管理和分配这些资源，如果我们网站的通信功能和网站都是紧耦合的，那么调配这些资源的工作就会比较复杂和繁琐，也很容易出问题。这样的问题还会还有很多，我这里不做细致分析了。做软件开发时候，有个原则，如果某个功能是可以通用的，该功能很需要统一管理时候，我们就应该把这个功能抽取成一个独立的系统或组件，并且这个系统或组件赋予一些增强级的功能特性，这样必定对整个系统的健壮性、可用性以及效率上有所提升。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　而我在分布式网站里所描述的通信技术，就是远程调用技术的一种，远程调用技术就是客户端和服务端的通信技术，它可以当做cs架构技术的一种，在java里有很多优秀的框架实现远程调用，例如java自带的RMI，spring自带的Httpinvoker，webservice技术等等。但是现有的这些技术满足不了互联网公司的远程调用需求，今天我将讲述一套我自己构思的一套远程调用技术，这个是借鉴了一些我们公司的类似软件的做法。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　该框架主要是针对java的，其他语言目前不能支持。首先我要总结远程调用技术要包括那些技术，它们分别是：</p>
<ol style="padding:0px 0px 0px 50px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);" class="list-paddingleft-2">
 <li><p>通信技术：远程调用就是通过网络技术将不同系统构成一个整体，因此通信技术是其重点，通信技术我这里选择的是netty技术，Netty提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。Netty会让我们开发通信程序变得简单，高效，其效率也是非常好的，同时它还支持多种不同的网络协议。</p></li>
 <li><p>序列化和反序列化技术：java的序列化技术是指将对象转换为byte数据，这些数据可以被还原为java对象，这种还原的过程就是反序列化了，该机制可以自动处理不同操作系统之间的差异，例如window下序列化的对象，可以在linux上进行重新构建。Java的jdk里自带了一个序列化和反序列化机制，熟悉hadoop的人知道hadoop设计了一套序列化和反序列化机制，为什么hadoop作者不选择使用java自带的序列化机制，这是因为java序列化机制非常复杂，复杂带来效率低下，java的序列化机制还有一个重要的缺点就是它序列化的二进制数据会非常大，因为java序列化时候会附带太多该对象的相关信息，过大的数据量就会影响网络传输的效率，因此hadoop自己设计了一套序列化和反序列化机制，hadoop不同节点之间的通信也是一种远程调用机制，因此我们发现好的序列化和反序列化技术对于远程调用是相当重要的。我们公司的远程调用框架序列化技术有两种一种就是java自带的序列化和反序列化机制，一种是hessian技术，它是一种更加高效的序列化和反序列化技术。</p></li>
 <li><p>压缩技术：做网络编程，最稀缺的资源就是宽带资源，如果传输数据过大，那么对数据的压缩就会显得十分重要，这里我推荐一个压缩技术snappy，它是一种高效的压缩和解压缩包，google公司内部广泛使用的一种压缩技术。</p></li>
 <li><p>高并发的技术：远程调用技术一定会是多线程，只有这样才能满足多个并发的处理请求，java在1.5的版本里提供了一个Executor框架，它在线程开发里引入了任务的概念，使得多线程的程序开发会更加合理和可控，关于executor的技术大家可以看看一本经典的书籍《java并发编程实践》。想让线程更加有效率，池技术也是并不可少的，apache的common-pool是一个非常好的池技术，我们可以将线程都预先创建好，然后放入到common-pool池里进行管理。</p></li>
 <li><p>非侵入式：这个也可以叫做松耦合，对于java的web开发，最好的解耦方式就是使用spring技术，当我们系统里把远程调用框架引入后，配置好相关的参数，我们可以把用于远程调用的方法定义在spring的配置文件里，那么在程序里调用的时候，利用spring直接获取这个bean，那么对于远程调用的开发就和我们在action里调用server的方法没啥区别了。下面是一段实例代码：</p></li>
</ol>
<p><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none;"><img onload="if(this.width>650) this.width=650;" src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;border:none;"></a></span></p>
<pre style="margin-top:0px;margin-bottom:0px;padding:0px;white-space:pre-wrap;font-family:'Courier New';">&lt;!--&nbsp;服务提供者配置&nbsp;--&gt;&lt;bean&nbsp;id="serverProvider"&nbsp;class="cn.com.sharpxiajun.RmifSpringProviderBean"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name="interface"&nbsp;value="cn.com.ITest"&gt;&lt;/property&gt;&lt;!--&nbsp;远程调用的接口&nbsp;--&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name="target"&nbsp;ref="clsTest"&gt;&lt;/property&gt;&lt;!--&nbsp;clsTest实现ITest的实现类，clsTest这里是一个bean的id值&nbsp;--&gt;&lt;/bean&gt;&lt;!--&nbsp;服务调用者配置&nbsp;--&gt;&lt;bean&nbsp;id="clientConsumer"&nbsp;class="cn.com.sharpxiajun.RmifSpringConsumerBean"&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name="interface"&nbsp;value="cn.com.clsTest"&gt;&lt;/property&gt;&lt;!--&nbsp;value就是Provider定义的target的接口实现类&nbsp;--&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name="seriaType"&nbsp;value="hessian"&gt;&lt;/property&gt;&lt;!--序列化方式&nbsp;&nbsp;--&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name="compress"&nbsp;value="true"&gt;&lt;/property&gt;&lt;!--&nbsp;压缩标记&nbsp;--&gt;&lt;/bean&gt;</pre>
<p><span class="cnblogs_code_copy" style="margin:0px;padding:0px 5px 0px 0px;line-height:1.5;"><a title="复制代码" style="margin:0px;padding:0px;text-decoration:underline;border:none;"><img onload="if(this.width>650) this.width=650;" src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码" style="margin:0px;padding:0px;border:none;"></a></span></p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">&nbsp;</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　6.负载均衡：分布式系统都离不开负载均衡，好的负载均衡可以充分利用好不同服务器的计算资源，提供系统的并发量和运算能力，对于网站而言（我们公司现在网站服务器不是太多）少于10台服务器可以使用两种策略：一种是简单轮询，比如有6台服务端，我们会把第一个请求给第一台服务器，第二个请求给第二台，依次类推，等6台循环完毕，又从第一台开始；第二种是随机方式，即使用random函数，当然更多的服务器我就不知道有什么轮询机制比较好，希望有知道的童鞋可以给我推荐下。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　我这里设计的远程调用框架，除了以上的功能外，我希望它还能有心跳管理机制，超时管理机制，服务分级管理，就是根据服务的重要性或者系统的繁忙度可以调节网络资源。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　哈哈，讲了这么久估计有童鞋可能有点烦了，不是说应用zookeeper的实例吗？怎么还没见到zookeeper的影子。别着急，zookeeper马上就要上场了。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　还是以我前面博客里写分布式网站讲起，服务端系统我们可以当做服务提供者，前端系统当做服务调用者，提供者可以类比商户，调用者可以类比客户，商户和客户可以直接进行交易，这种直接交易方式非常原始甚至还会有风险，现代社会商户和客户直接的交易十分高效，高效的原因是因为有一个规范的大市场，商户和客户的交易在市场里进行的，这样交易会变得更加安全和高效，我设计的分布式框架最大的特点就是提供了一个类似市场的角色，它来管理服务提供者和服务调用者，我把这个功能模块称为远程调用管理组件。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　远程调用管理组件是本框架的核心，它的主要作用是接收服务端提供者的注册的通知，该通知一般是接口以及该接口的实现类还有服务器的ip地址，管理组件会将这些通知记录下来，并且根据配置对这些服务程序进行分组和标记，注册好的信息管理组件会将这些信息推送到服务调用者。远程调用管理组件还包含心跳机制，这个心跳机制是针对服务提供者，通过心跳机制检测服务提供者的健康状况，管理组件不会检测服务调用者的健康状态，因为这个没必要，因为本框架的使用还是调用者直接去请求提供者，逻辑上是没必要关心调用者的状态，这和bs架构里浏览器一样，我们不会去关心浏览器用户是不是存在。服务提供者、服务调用者和远程调用管理组件的关系如下图所示：</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);"><img onload="if(this.width>650) this.width=650;" src="http://images.cnitblog.com/blog/306623/201309/02232732-649750ef06b04bc7bcd76b283e6060c9.png" alt="" style="margin:0px;padding:0px;border:0px;"></p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　远程调用框架运行的过程是：当服务提供者启动时候，它会将自己的ip地址和注册的方法传输到远程调用管理组件，管理组件接收到注册信息会将这些信息存储下来，存储技术就是使用zookeeper，存储成功后，管理组件会将成功通知传回给服务提供者，同时管理组件还会通过心跳检测服务提供者是否健康；当服务调用者启动时候，它会向管理组件请求服务提供者信息，管理组件接收到请求后会将相关信息推送给服务调用者。在实际系统运行时候，服务调用者直接和服务提供者进行通信交互了，通信方式是netty，如果调用者和提供者有相关变化，都会先通知服务管理组件，服务管理组件会将相关变更信息推送给相应的系统。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">&nbsp;</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　远程调用管理组件主要是通过zookeeper实现，zookeeper拥有一个层次的命名空间，它的模型是一个树状结构，树状结构是一个强大的数据类型，它几乎能存储所有不同的数据类型，我们通过zookeeper将这些信息保存起来，便于我们管理整个远程调用框架，同时zookeeper还是高可靠的，这个我在前面zookeeper文章里讲到了，这样就保证了整个远程调用框架的稳定性，实际应用中我们会将组件编译成一个jar包，不同的项目直接引用这个jar包，这样管理组件服务端和服务的提供者和调用者就联系起来。至于提供者和调用者的通信机制是直接进行，因为我们将通信程序集成在jar包里，只不过相应的管理机制抽取到外部服务端进行统一管理。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">&nbsp;</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">　　这就是我设计的远程调用框架，可惜的是，这个构思我还没有真正实现过，今天拿出来是想体现zookeeper的实际应用，为我后面讲解zookeeper做铺垫，至于是否可行，看以后有没有机会开发个类似的系统，到时估计还有很多意想不到的问题要解决。</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">&nbsp;</p>
<p style="margin:10px auto;padding:0px;font-family:verdana, 'ms song', '宋体', Arial, '微软雅黑', Helvetica, sans-serif;font-size:12px;line-height:18px;white-space:normal;background-color:rgb(238,238,238);">&nbsp; &nbsp; （远程调用服务的设计我参考了技术友人马德鑫的设计，他曾是淘宝的技术架构师）</p>
<p><br></p>
