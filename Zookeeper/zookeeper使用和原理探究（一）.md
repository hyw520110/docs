<p>转载来源：<a href="http://www.blogjava.net/BucketLi/archive/2010/12/21/341268.html">http://www.blogjava.net/BucketLi/archive/2010/12/21/341268.html</a></p>
<p style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px;white-space:normal"><span style="font-size:9px;line-height:normal;font-family:'times new roman'"><span style="font-size:13px"><strong>zookeeper</strong><span style="font-family:宋体"><strong>介绍<br></strong></span>zookeeper<span style="font-family:宋体">是一个为分布式应用提供一致性服务的软件，它是开源的</span>Hadoop<span style="font-family:宋体">项目中的一个子项目，并且根据</span>google<span style="font-family:宋体">发表的</span>&lt;The Chubby lock service for loosely-coupled distributed systems&gt;<span style="font-family:宋体">论文来实现的，接下来我们首先来安装使用下这个软件，然后再来探索下其中比较重要一致性算法。</span><br></span></span><br><strong style="font-size:13px">zookeeper<span style="font-family:宋体">安装和使用<br></span></strong><span style="font-size:13px">zookeeper<span style="font-family:宋体">的安装基本上可以按照</span> http://hadoop.apache.org/zookeeper/docs/current/ zookeeperStarted.html <span style="font-family:宋体">这个页面上的步骤完成安装，这里主要介绍下部署一个集群的步骤，因为这个官方页面似乎讲得并不是非常详细</span>(Running Replicated Zookeeper)<span style="font-family:宋体">。<br></span><span style="font-family:宋体"><br>由于手头机器不足，所以在一台机器上部署了</span>3<span style="font-family:宋体">个</span>server,<span style="font-family:宋体">如果你手头也比较紧，也可以这么做。那么我建了</span>3<span style="font-family:宋体">个文件夹，如下<br></span></span><strong><span style="font-size:13px">server1 &nbsp; server2 &nbsp; server3<br></span></strong><span style="font-family:宋体"><span style="font-size:13px"><br>然后每个文件夹里面解压一个zookeeper的下载包，并且还建了几个文件夹，总体结构如下,最后那个是下载过来压缩包的解压文件<br></span></span><strong><span style="font-size:13px"><strong>data dataLog logs zookeeper-3.3.2<br></strong></span><br></strong><span style="font-family:宋体"><span style="font-size:13px">那么首先进入data目录，创建一个myid的文件，里面写入一个数字，比如我这个是server1,那么就写一个1，server2对应myid文件就写入2，server3对应myid文件就写个3<br></span></span><br><span style="font-family:宋体"><span style="font-size:13px">然后进入<strong>zookeeper-3.3.2/conf</strong>目录，那么如果是刚下过来，会有3个文件，<strong>configuration.xml, log4j.properties,zoo_sample.cfg</strong>,这3个文件我们首先要做的就是在这个目录创建一个zoo.cfg的配置文件，当然你可以把zoo_sample.cfg文件改成zoo.cfg，配置的内容如下所示：</span></span><br><span style="color:red"><span style="font-size:13px">tickTime=2000<br>initLimit=5<br>syncLimit=2<br>dataDir=xxxx/zookeeper/server1/data<br>dataLogDir=xxx/zookeeper/server1/dataLog<br>clientPort=2181<br></span></span><span style="font-size:13px">server.1=127.0.0.1:2888:3888<br>server.2=127.0.0.1:2889:3889<br>server.3=127.0.0.1:2890:3890<span style="font-family:宋体"><br></span></span><br><span style="font-family:宋体"><span style="font-size:13px">标红的几个配置应该官网讲得很清楚了，只是需要注意的是clientPort这个端口如果你是在1台机器上部署多个server,那么每台机器都要不同的clientPort，比如我server1是2181,server2是2182，server3是2183，dataDir和dataLogDir也需要区分下。 <br><br>最后几行唯一需要注意的地方就是 server.X 这个数字就是对应 data/myid中的数字。你在3个server的myid文件中分别写入了1，2，3，那么每个server中的zoo.cfg都配server.1,server.2,server.3就OK了。因为在同一台机器上，后面连着的2个端口3个server都不要一样，否则端口冲突，其中第一个端口用来集群成员的信息交换，第二个端口是在leader挂掉时专门用来进行选举leader所用。<br><br></span></span><span style="font-family:宋体"><span style="font-size:13px">进入zookeeper-3.3.2/bin 目录中，<strong>./</strong></span></span><span style="font-family:宋体"><span style="font-size:13px"><strong>zkServer.sh start</strong></span></span><span style="font-family:宋体"><span style="font-size:13px">启动一个server,这时会报大量错误？其实没什么关系，因为现在集群只起了1台server，zookeeper服务器端起来会根据zoo.cfg的服务器列表发起选举leader的请求，因为连不上其他机器而报错，那么当我们起第二个zookeeper实例后，leader将会被选出，从而一致性服务开始可以使用，这是因为3台机器只要有2台可用就可以选出leader并且对外提供服务(2n+1台机器，可以容n台机器挂掉)。<br><br></span></span><span style="font-family:宋体"><span style="font-size:13px">接下来就可以使用了，我们可以先通过 zookeeper自带的客户端交互程序来简单感受下zookeeper到底做一些什么事情。进入zookeeper-3.3.2/bin（3个server中任意一个）下，<strong>./zkCli.sh &#xfffd;server 127.0.0.1:2182</strong>,我连的是开着2182端口的机器。<br><br>那么，首先我们随便打个命令，因为zookeeper不认识，他会给出命令的help,如下图</span></span><br><img onload="if(this.width>650) this.width=650;" border="0" src="http://www.blogjava.net/images/blogjava_net/bucketli/dddd.jpg" style="border:0px"><br><span style="font-size:13px">ls(<span style="font-family:宋体">查看当前节点数据</span>),<br>ls2(<span style="font-family:宋体">查看当前节点数据并能看到更新次数等数据</span>) ,<br>create(<span style="font-family:宋体">创建一个节点</span>) ,<br>get(<span style="font-family:宋体">得到一个节点，包含数据和更新次数等数据</span>),<br>set(<span style="font-family:宋体">修改节点</span>)<br>delete(<span style="font-family:宋体">删除一个节点</span>)<br></span><span style="font-family:宋体"><br><span style="font-size:13px">通过上述命令实践，我们可以发现，zookeeper使用了一个类似文件系统的树结构，数据可以挂在某个节点上，可以对这个节点进行删改。另外我们还发现，当改动一个节点的时候，集群中活着的机器都会更新到一致的数据。 <br></span></span><br><span style="font-size:13px"><strong>zookeeper</strong><span style="font-family:宋体"><strong>的数据模型<br></strong></span></span><span style="font-family:宋体"><span style="font-size:13px">在简单使用了zookeeper之后，我们发现其数据模型有些像操作系统的文件结构，结构如下图所示<br></span></span><img onload="if(this.width>650) this.width=650;" border="0" src="http://www.blogjava.net/images/blogjava_net/bucketli/XX.jpg" style="border:0px"><br><br><br><span style="font-size:13px">(1)<span style="font-family:宋体">每个节点在</span>zookeeper<span style="font-family:宋体">中叫做</span>znode,<span style="font-family:宋体">并且其有一个唯一的路径标识，如</span>/SERVER2<span style="font-family:宋体">节点的标识就为</span>/APP3/SERVER2<br>(2)Znode<span style="font-family:宋体">可以有子</span>znode<span style="font-family:宋体">，并且</span>znode<span style="font-family:宋体">里可以存数据，但是</span>EPHEMERAL<span style="font-family:宋体">类型的节点不能有子节点<br></span>(3)Znode<span style="font-family:宋体">中的数据可以有多个版本，比如某一个路径下存有多个数据版本，那么查询这个路径下的数据就需要带上版本。<br></span>(4)znode <span style="font-family:宋体">可以是临时节点，一旦创建这个</span> znode <span style="font-family:宋体">的客户端与服务器失去联系，这个</span> znode <span style="font-family:宋体">也将自动删除，</span>Zookeeper <span style="font-family:宋体">的客户端和服务器通信采用长连接方式，每个客户端和 &nbsp;服务器通过心跳来保持连接，这个连接状态称为</span> session<span style="font-family:宋体">，如果</span> znode <span style="font-family:宋体">是临时节点，这个</span> session <span style="font-family:宋体">失效，</span>znode <span style="font-family:宋体">也就删除了<br></span>(5)znode <span style="font-family:宋体">的目录名可以自动编号，如</span> App1 <span style="font-family:宋体">已经存在，再创建的话，将会自动命名为</span> App2 <br>(6)znode <span style="font-family:宋体">可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个功能是</span>zookeeper<span style="font-family:宋体">对于应用最重要的特性，通过这个特性可以实现的功能包括配置的集中管理，集群管理，分布式锁等等。</span></span><br><br><strong><span style="font-family:宋体">通过</span>java<span style="font-family:宋体">代码使用</span>zookeeper <br></strong><span style="font-size:13px">Zookeeper<span style="font-family:宋体">的使用主要是通过创建其</span>jar<span style="font-family:宋体">包下的</span>Zookeeper<span style="font-family:宋体">实例，并且调用其接口方法进行的，主要的操作就是对</span>znode<span style="font-family:宋体">的增删改操作，监听</span>znode<span style="font-family:宋体">的变化以及处理。</span></span><br><br><span style="font-family:宋体"><span style="font-size:13px">以下为主要的API使用和解释</span></span></p>
<img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px">
<span style="color:#008000">//</span>
<span style="color:#008000">创建一个Zookeeper实例，第一个参数为目标服务器地址和端口，第二个参数为Session超时时间，第三个为节点变化时的回调方法</span>
<span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" id="Codehighlighter1_136_262_Open_Image" src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockStart.gif" style="border:0px"></span>
<span style="color:#000000">ZooKeeper zk </span>
<span style="color:#000000">=</span>
<span style="color:#0000ff">new</span>
<span style="color:#000000"> ZooKeeper(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">127.0.0.1:2181</span>
<span style="color:#000000">"</span>
<span style="color:#000000">, </span>
<span style="color:#000000">500000</span>
<span style="color:#000000">,</span>
<span style="color:#0000ff">new</span>
<span style="color:#000000"> Watcher() </span>
<span id="Codehighlighter1_136_262_Open_Text"><span style="color:#000000">{<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" style="border:0px"></span><span style="color:#008000">//</span><span style="color:#008000"> 监控所有被触发的事件</span><span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" id="Codehighlighter1_216_254_Open_Image" src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockStart.gif" style="border:0px"></span><span style="color:#0000ff">public</span><span style="color:#0000ff">void</span><span style="color:#000000"> process(WatchedEvent event) </span><span id="Codehighlighter1_216_254_Open_Text"><span style="color:#000000">{<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/InBlock.gif" style="border:0px"></span><span style="color:#008000">//</span><span style="color:#008000">dosomething</span><span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedSubBlockEnd.gif" style="border:0px"></span><span style="color:#000000"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></span><span style="color:#000000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/ExpandedBlockEnd.gif" style="border:0px"> &nbsp; &nbsp; &nbsp;}</span></span>
<span style="color:#000000">);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#008000">//</span>
<span style="color:#008000">创建一个节点root，数据是mydata,不进行ACL权限控制，节点为永久性的(即客户端shutdown了也不会消失)</span>
<span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#000000">zk.create(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/root</span>
<span style="color:#000000">"</span>
<span style="color:#000000">, </span>
<span style="color:#000000">"</span>
<span style="color:#000000">mydata</span>
<span style="color:#000000">"</span>
<span style="color:#000000">.getBytes(),Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#008000">//</span>
<span style="color:#008000">在root下面创建一个childone znode,数据为childone,不进行ACL权限控制，节点为永久性的</span>
<span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#000000">zk.create(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/root/childone</span>
<span style="color:#000000">"</span>
<span style="color:#000000">,</span>
<span style="color:#000000">"</span>
<span style="color:#000000">childone</span>
<span style="color:#000000">"</span>
<span style="color:#000000">.getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#008000">//</span>
<span style="color:#008000">取得/root节点下的子节点名称,返回List&lt;String&gt;</span>
<span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#000000">zk.getChildren(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/root</span>
<span style="color:#000000">"</span>
<span style="color:#000000">,</span>
<span style="color:#0000ff">true</span>
<span style="color:#000000">);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#008000">//</span>
<span style="color:#008000">取得/root/childone节点下的数据,返回byte[]</span>
<span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#000000">zk.getData(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/root/childone</span>
<span style="color:#000000">"</span>
<span style="color:#000000">, </span>
<span style="color:#0000ff">true</span>
<span style="color:#000000">, </span>
<span style="color:#0000ff">null</span>
<span style="color:#000000">);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#008000">//</span>
<span style="color:#008000">修改节点/root/childone下的数据，第三个参数为版本，如果是-1，那会无视被修改的数据版本，直接改掉</span>
<span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#000000">zk.setData(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/root/childone</span>
<span style="color:#000000">"</span>
<span style="color:#000000">,</span>
<span style="color:#000000">"</span>
<span style="color:#000000">childonemodify</span>
<span style="color:#000000">"</span>
<span style="color:#000000">.getBytes(), </span>
<span style="color:#000000">-</span>
<span style="color:#000000">1</span>
<span style="color:#000000">);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#008000">//</span>
<span style="color:#008000">删除/root/childone这个节点，第二个参数为版本，－1的话直接删除，无视版本</span>
<span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#000000">zk.delete(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/root/childone</span>
<span style="color:#000000">"</span>
<span style="color:#000000">, </span>
<span style="color:#000000">-</span>
<span style="color:#000000">1</span>
<span style="color:#000000">);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#008000">//</span>
<span style="color:#008000">关闭session</span>
<span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#000000">zk.close();<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<br style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px;white-space:normal">
<strong style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px;white-space:normal"><span style="font-family:'courier new';color:black"><span style="font-size:13px">Zookeeper<span style="font-family:宋体">的主流应用场景实现思路（除去官方示例）</span></span></span><br></strong>
<span style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px"><span style="font-family:'courier new';color:black"><strong><br>(1)</strong></span><span style="font-family:宋体;color:black"><strong>配置管理<br></strong></span></span>
<span style="font-size:13px;line-height:19px;font-family:宋体"><span style="font-size:13px">集中式的配置管理在应用集群中是非常常见的，一般商业公司内部都会实现一套集中的配置管理中心，应对不同的应用集群对于共享各自配置的需求，并且在配置变更时能够通知到集群中的每一个机器。<br></span></span>
<span style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px"><span style="font-family:'courier new';color:black"><br>Zookeeper</span><span style="font-family:宋体;color:black">很容易实现这种集中式的配置管理，比如将</span><span style="font-family:'courier new';color:black">APP1</span><span style="font-family:宋体;color:black">的所有配置配置到</span><span style="font-family:'courier new';color:black">/APP1 znode</span><span style="font-family:宋体;color:black">下，</span><span style="font-family:'courier new';color:black">APP1</span><span style="font-family:宋体;color:black">所有机器一启动就对</span><span style="font-family:'courier new';color:black">/APP1</span><span style="font-family:宋体;color:black">这个节点进行监控</span><span style="font-family:'courier new';color:black">(zk.exist(</span><span style="font-family:'courier new';color:#2a00ff">"/APP1"</span><span style="font-family:'courier new';color:black">,true)),</span><span style="font-family:宋体;color:black">并且实现回调方法</span><span style="font-family:'courier new';color:black">Watcher</span><span style="font-family:宋体;color:black">，那么在</span><span style="font-family:'courier new';color:black">zookeeper</span><span style="font-family:宋体;color:black">上</span><span style="font-family:'courier new';color:black">/APP1 znode</span><span style="font-family:宋体;color:black">节点下数据发生变化的时候，每个机器都会收到通知，</span><span style="font-family:'courier new';color:black">Watcher</span><span style="font-family:宋体;color:black">方法将会被执行，那么应用再取下数据即可</span><span style="font-family:'courier new';color:black">(zk.getData(</span><span style="font-family:'courier new';color:#2a00ff">"/APP1",false,null</span><span style="font-family:'courier new';color:black">));<br></span></span>
<span style="font-size:13px;line-height:19px;font-family:宋体"><span style="font-size:13px"><br>以上这个例子只是简单的粗颗粒度配置监控，细颗粒度的数据可以进行分层级监控，这一切都是可以设计和控制的。</span></span>
<img onload="if(this.width>650) this.width=650;" border="0" src="http://www.blogjava.net/images/blogjava_net/bucketli/ttt.jpg" style="border:0px;color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px;white-space:normal">
<br style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px;white-space:normal">
<strong style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px;white-space:normal"><span style="font-size:13px"><span style="font-family:'courier new';color:black">(2)</span><span style="font-family:宋体;color:black">集群管理</span></span><br></strong>
<span style="font-size:13px;line-height:19px;font-family:宋体"><span style="font-size:13px">应用集群中，我们常常需要让每一个机器知道集群中（或依赖的其他某一个集群）哪些机器是活着的，并且在集群机器因为宕机，网络断链等原因能够不在人工介入的情况下迅速通知到每一个机器。<br></span></span>
<span style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px"><span style="font-family:'courier new';color:black"><br>Zookeeper</span><span style="font-family:宋体;color:black">同样很容易实现这个功能，比如我在</span><span style="font-family:'courier new';color:black">zookeeper</span><span style="font-family:宋体;color:black">服务器端有一个</span><span style="font-family:'courier new';color:black">znode</span><span style="font-family:宋体;color:black">叫</span><span style="font-family:'courier new';color:black">/APP1SERVERS,</span><span style="font-family:宋体;color:black">那么集群中每一个机器启动的时候都去这个节点下创建一个</span><span style="font-family:'courier new';color:black">EPHEMERAL</span><span style="font-family:宋体;color:black">类型的节点，比如</span><span style="font-family:'courier new';color:black">server1</span><span style="font-family:宋体;color:black">创建</span><span style="font-family:'courier new';color:black">/APP1SERVERS/SERVER1(</span><span style="font-family:宋体;color:black">可以使用</span><span style="font-family:'courier new';color:black">ip,</span><span style="font-family:宋体;color:black">保证不重复</span><span style="font-family:'courier new';color:black">)</span><span style="font-family:宋体;color:black">，</span><span style="font-family:'courier new';color:black">server2</span><span style="font-family:宋体;color:black">创建</span><span style="font-family:'courier new';color:black">/APP1SERVERS/SERVER2</span><span style="font-family:宋体;color:black">，然后</span><span style="font-family:'courier new';color:black">SERVER1</span><span style="font-family:宋体;color:black">和</span><span style="font-family:'courier new';color:black">SERVER2</span><span style="font-family:宋体;color:black">都</span><span style="font-family:'courier new';color:black">watch /APP1SERVERS</span><span style="font-family:宋体;color:black">这个父节点，那么也就是这个父节点下数据或者子节点变化都会通知对该节点进行</span><span style="font-family:'courier new';color:black">watch</span><span style="font-family:宋体;color:black">的客户端。因为</span><span style="font-family:'courier new';color:black">EPHEMERAL</span><span style="font-family:宋体;color:black">类型节点有一个很重要的特性，就是客户端和服务器端连接断掉或者</span><span style="font-family:'courier new';color:black">session</span><span style="font-family:宋体;color:black">过期就会使节点消失，那么在某一个机器挂掉或者断链的时候，其对应的节点就会消失，然后集群中所有对</span><span style="font-family:'courier new';color:black">/APP1SERVERS</span><span style="font-family:宋体;color:black">进行</span><span style="font-family:'courier new';color:black">watch</span><span style="font-family:宋体;color:black">的客户端都会收到通知，然后取得最新列表即可。<br></span></span>
<span style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px"><span style="font-family:宋体;color:black"><br>另外有一个应用场景就是集群选</span><span style="font-family:'courier new';color:black">master,</span><span style="font-family:宋体;color:black">一旦</span><span style="font-family:'courier new';color:black">master</span><span style="font-family:宋体;color:black">挂掉能够马上能从</span><span style="font-family:'courier new';color:black">slave</span><span style="font-family:宋体;color:black">中选出一个</span><span style="font-family:'courier new';color:black">master,</span><span style="font-family:宋体;color:black">实现步骤和前者一样，只是机器在启动的时候在</span><span style="font-family:'courier new';color:black">APP1SERVERS</span><span style="font-family:宋体;color:black">创建的节点类型变为</span><span style="font-family:'courier new';color:black">EPHEMERAL_SEQUENTIAL</span><span style="font-family:宋体;color:black">类型，这样每个节点会自动被编号，例如</span></span>
<img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px">
<span style="color:#000000">zk.create(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/testRootPath/testChildPath1</span>
<span style="color:#000000">"</span>
<span style="color:#000000">,</span>
<span style="color:#000000">"</span>
<span style="color:#000000">1</span>
<span style="color:#000000">"</span>
<span style="color:#000000">.getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px">zk.create(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/testRootPath/testChildPath2</span>
<span style="color:#000000">"</span>
<span style="color:#000000">,</span>
<span style="color:#000000">"</span>
<span style="color:#000000">2</span>
<span style="color:#000000">"</span>
<span style="color:#000000">.getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px">zk.create(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/testRootPath/testChildPath3</span>
<span style="color:#000000">"</span>
<span style="color:#000000">,</span>
<span style="color:#000000">"</span>
<span style="color:#000000">3</span>
<span style="color:#000000">"</span>
<span style="color:#000000">.getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#008000">//</span>
<span style="color:#008000"> 创建一个子目录节点</span>
<span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#000000">zk.create(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/testRootPath/testChildPath4</span>
<span style="color:#000000">"</span>
<span style="color:#000000">,</span>
<span style="color:#000000">"</span>
<span style="color:#000000">4</span>
<span style="color:#000000">"</span>
<span style="color:#000000">.getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL_SEQUENTIAL);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px">System.out.println(zk.getChildren(</span>
<span style="color:#000000">"</span>
<span style="color:#000000">/testRootPath</span>
<span style="color:#000000">"</span>
<span style="color:#000000">, </span>
<span style="color:#0000ff">false</span>
<span style="color:#000000">));<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>
<span style="color:#4b4b4b;font-family:verdana, geneva, arial, helvetica, sans-serif;font-size:13px;line-height:19px"><span style="font-family:宋体;color:black">打印结果：</span></span>
<span style="font-size:13px;line-height:19px;font-family:'courier new'"><span style="font-size:13px">[testChildPath10000000000, testChildPath20000000001, testChildPath40000000003, testChildPath30000000002]<br><br></span><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px">zk.create("/testRootPath", "testRootData".getBytes(),Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><span style="color:#008000">//</span><span style="color:#008000"> 创建一个子目录节点</span><span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>zk.create("/testRootPath/testChildPath1","1".getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px">zk.create("/testRootPath/testChildPath2","2".getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px">zk.create("/testRootPath/testChildPath3","3".getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><span style="color:#008000">//</span><span style="color:#008000"> 创建一个子目录节点</span><span style="color:#008000"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"></span>zk.create("/testRootPath/testChildPath4","4".getBytes(), Ids.OPEN_ACL_UNSAFE,CreateMode.EPHEMERAL);<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px">System.out.println(zk.getChildren("/testRootPath", <span style="color:#0000ff">false</span>));<br><img onload="if(this.width>650) this.width=650;" src="http://www.blogjava.net/Images/OutliningIndicators/None.gif" style="border:0px"><span style="font-family:宋体;font-size:13px"><span style="font-size:13px">打印结果:<span style="font-family:'courier new'">[testChildPath2, testChildPath1, testChildPath4, testChildPath3]<br></span></span></span><span style="font-size:13px"><span style="font-family:宋体"><br>我们默认规定编号最小的为</span>master,<span style="font-family:宋体">所以当我们对</span>/APP1SERVERS<span style="font-family:宋体">节点做监控的时候，得到服务器列表，只要所有集群机器逻辑认为最小编号节点为</span>master<span style="font-family:宋体">，那么</span>master<span style="font-family:宋体">就被选出，而这个</span>master<span style="font-family:宋体">宕机的时候，相应的</span>znode<span style="font-family:宋体">会消失，然后新的服务器列表就被推送到客户端，然后每个节点逻辑认为最小编号节点为</span>master<span style="font-family:宋体">，这样就做到动态</span>master<span style="font-family:宋体">选举。<br></span><img onload="if(this.width>650) this.width=650;" border="0" src="http://www.blogjava.net/images/blogjava_net/bucketli/xxx.jpg" style="border:0px"><br><br><strong>总结</strong><p style="margin-left:24px;"><span style="font-family:宋体">我们初步使用了一下</span>zookeeper<span style="font-family:宋体">并且尝试着描述了几种应用场景的具体实现思路，接下来的文章，我们会尝试着去探究一下</span>zookeeper<span style="font-family:宋体">的高可用性与</span>leaderElection<span style="font-family:宋体">算法。</span></p><p><span style="font-family:宋体"><strong>参考</strong>：</span><a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" style="color:#1a8bc8">http://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/</a></p><p><a href="http://hadoop.apache.org/zookeeper/docs/current/" style="color:#1a8bc8">http://hadoop.apache.org/zookeeper/docs/current/</a></p><p><a href="http://rdc.taobao.com/team/jm/archives/448" style="color:#1a8bc8">http://rdc.taobao.com/team/jm/archives/448</a></p></span></span>
<p><br></p>
