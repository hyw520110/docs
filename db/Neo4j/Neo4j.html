<span id="chapter1-index"></span>
<h1>第 1 章 Neo4j的亮点<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>作为一款强健的，可伸缩的高性能数据库，Neo4j最适合完整的企业部署或者用于一个轻量级项目中完整服务器的一个子集存在。</p> 
  <p>它包括如下几个显著特点:</p> 
  <ul class="simple"> 
   <li>完整的ACID支持</li> 
   <li>高可用性</li> 
   <li>轻易扩展到上亿级别的节点和关系</li> 
   <li>通过遍历工具高速检索数据</li> 
  </ul> 
  <p>适当的ACID操作是保证数据一致性的基础。Neo4j确保了在一个事务里面的多个操作同时发生，保证数据一致性。不管是采用嵌入模式还是多服务器集群部署，都支持这一特性。更多详细的介绍，请参考章节:transactions。</p> 
  <p>可靠的图型存储可以非常轻松的集成到任何一个应用中。随着我们开发的应用在运营中不断发展，性能问题肯定会逐步凸显出来，而Neo4j不管应用如何变化，他只会受到计算机硬件性能的影响，不受业务本身的约束。部署一个neo4j服务器便可以承载上亿级的节点和关系。当然，当单节点无法承载我们的数据需求时，我们可以进行分布式集群部署，详细的细节，请参考章节：ha。将图数据库用于存储关系复杂的数据是他最大的优势。通过Neo4j提供的遍历工具，可以非常高效的进行数据检索，每秒可以达到上亿级的检索量。一个检索操作类似于RDBMS里面的连接（_join_）操作。</p> 
 </div>
</blockquote><span id="id1"></span>
<h1>第 2 章 图数据库概要<a class="headerlink" href="#chapter2-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  这个章节包括一个对图数据模型的介绍以及将它与其他我们常见的数据持久化模型的比较。
 </div>
</blockquote> 
<div class="toctree-wrapper compound"> 
 <ul> 
  <li class="toctree-l1"><a class="reference internal" href="chapter2_1.html">2.1. 什么是图数据库?</a>
   <ul> 
    <li class="toctree-l2"><a class="reference internal" href="chapter2_1.html#id2">2.1.1. 一个图由无数的节点和关系组成</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter2_1.html#id3">2.1.2. 关系将图各个部分组织起来</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter2_1.html#traversal">2.1.3. 用 Traversal 进行数据库查询</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter2_1.html#id4">2.1.4. 为节点和关系建立索引</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter2_1.html#neo4j">2.1.5. Neo4j是一个图数据库</a></li> 
   </ul> </li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter2_2.html">2.2. 比较各种数据库模型</a>
   <ul> 
    <li class="toctree-l2"><a class="reference internal" href="chapter2_2.html#rdbms">2.2.1. 从图数据库转换成 RDBMS</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter2_2.html#key-value">2.2.2. 从图数据库转换成Key-Value数据库</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter2_2.html#id2">2.2.3. 从图数据库转换成列数据库</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter2_2.html#id3">2.2.4. 从图数据库转换成文档型数据库</a></li> 
   </ul> </li> 
 </ul> 
</div><span id="id1"></span>
<h1>2.1. 什么是图数据库?<a class="headerlink" href="#chapter2-1-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  图数据库用图来存储数据，是最接近高性能的一种用于存储数据的数据结构方式之一。让我们跟随下面的图表，用他们来解释图数据库相关概念。我们将跟随图表中箭头方向来读懂图想表达的真正含义。
 </div>
</blockquote> 
<div class="section" id="id2"> 
 <h2>2.1.1. 一个图由无数的节点和关系组成<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>“一张图 – 数据记录在 → 节点 → 包括的 → 属性里面” 最简单的图是单节点的，一个记录，记录了一些属性。一个节点可以从单属性开始，成长为成千上亿，虽然会有一点点麻烦。从某种意义上讲，将数据用关系连接起来分布到不同节点上才是有意义的。</p> 
   <div class="figure"> 
    <img alt="../_images/graphdb-gve.svg.png" src="../_images/graphdb-gve.svg.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>2.1.2. 关系将图各个部分组织起来<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   “节点 — 被组织 → 关系 — 可以有 → 属性” 关系可以将节点组织成任意的结构，允许一张图被组织成一个列表，一棵树，一张地图，或者一个复杂的实体 – 这个实体本身也是由复杂的，关系高度关联的结构组成。
  </div>
 </blockquote> 
</div> 
<div class="section" id="traversal"> 
 <h2>2.1.3. 用 Traversal 进行数据库查询<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>“一个 Traversal — 导航 → 一张图; 他 — 标示 → 路径 — 包含 → 节点” 一次 Traversal, 你可以理解为是你通过一种算法，从一些开始节点开始查询与其关联的节点，比如你想找到 “我朋友喜欢但我不喜欢的那首音乐是什么呢？”，又或者 “如果断电了，拿下服务器的服务会首影响？”等等问题。</p> 
   <div class="figure"> 
    <img alt="../_images/graphdb-traversal.svg.png" src="../_images/graphdb-traversal.svg.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>2.1.4. 为节点和关系建立索引<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>“一个索引 — 映射到 → 属性 — 属于 → 节点或者关系” 经常，你想通过某一给定的属性值找到节点或者关系。比起通过遍历我们的图来书，用索引将会更加高效。比如“找到用户名是tony的用户”。</p> 
   <div class="figure"> 
    <img alt="../_images/graphdb-indexes.svg.png" src="../_images/graphdb-indexes.svg.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="neo4j"> 
 <h2>2.1.5. Neo4j是一个图数据库<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>“一个图数据库 — 管理 → 一张图 和与图相关的 → 索引” Neo4j是一个有商业支持的开源图数据库。他被设计来用于拿下数据不断高速成长的数据存储，用高效的图数据结构代替传统的表设计。用Neo4j工作，您的应用将得到图的所有优越表现，以及您期望的高可靠性。</p> 
   <div class="figure"> 
    <img alt="../_images/graphdb-overview.svg.png" src="../_images/graphdb-overview.svg.png"> 
   </div> 
  </div>
 </blockquote> 
</div>
<h2>2.1.1. 一个图由无数的节点和关系组成<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>“一张图 – 数据记录在 → 节点 → 包括的 → 属性里面” 最简单的图是单节点的，一个记录，记录了一些属性。一个节点可以从单属性开始，成长为成千上亿，虽然会有一点点麻烦。从某种意义上讲，将数据用关系连接起来分布到不同节点上才是有意义的。</p> 
  <div class="figure"> 
   <img alt="../_images/graphdb-gve.svg.png" src="../_images/graphdb-gve.svg.png"> 
  </div> 
 </div>
</blockquote>
<h2>2.1.2. 关系将图各个部分组织起来<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  “节点 — 被组织 → 关系 — 可以有 → 属性” 关系可以将节点组织成任意的结构，允许一张图被组织成一个列表，一棵树，一张地图，或者一个复杂的实体 – 这个实体本身也是由复杂的，关系高度关联的结构组成。
 </div>
</blockquote>
<h2>2.1.3. 用 Traversal 进行数据库查询<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>“一个 Traversal — 导航 → 一张图; 他 — 标示 → 路径 — 包含 → 节点” 一次 Traversal, 你可以理解为是你通过一种算法，从一些开始节点开始查询与其关联的节点，比如你想找到 “我朋友喜欢但我不喜欢的那首音乐是什么呢？”，又或者 “如果断电了，拿下服务器的服务会首影响？”等等问题。</p> 
  <div class="figure"> 
   <img alt="../_images/graphdb-traversal.svg.png" src="../_images/graphdb-traversal.svg.png"> 
  </div> 
 </div>
</blockquote>
<h2>2.1.4. 为节点和关系建立索引<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>“一个索引 — 映射到 → 属性 — 属于 → 节点或者关系” 经常，你想通过某一给定的属性值找到节点或者关系。比起通过遍历我们的图来书，用索引将会更加高效。比如“找到用户名是tony的用户”。</p> 
  <div class="figure"> 
   <img alt="../_images/graphdb-indexes.svg.png" src="../_images/graphdb-indexes.svg.png"> 
  </div> 
 </div>
</blockquote>
<h2>2.1.5. Neo4j是一个图数据库<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>“一个图数据库 — 管理 → 一张图 和与图相关的 → 索引” Neo4j是一个有商业支持的开源图数据库。他被设计来用于拿下数据不断高速成长的数据存储，用高效的图数据结构代替传统的表设计。用Neo4j工作，您的应用将得到图的所有优越表现，以及您期望的高可靠性。</p> 
  <div class="figure"> 
   <img alt="../_images/graphdb-overview.svg.png" src="../_images/graphdb-overview.svg.png"> 
  </div> 
 </div>
</blockquote><span id="id1"></span>
<h1>2.2. 比较各种数据库模型<a class="headerlink" href="#chapter2-2-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  图数据库通过在一张图上存储节点和关系来持久化我们的数据结构。比起其他持久化数据模型如何呢？因为图是一种常规数据结构，让我们与其他的进行一下比较试试看。
 </div>
</blockquote> 
<div class="section" id="rdbms"> 
 <h2>2.2.1. 从图数据库转换成 RDBMS<a class="headerlink" href="#rdbms" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>将所有的数据用竖立的堆栈表示，并且保持他们直接的关系，你可以看到下面一张图。一个 RDBMS 被优化用于聚合数据，而Neo4j擅长于高度关联的数据。</p> 
   <p>图 2.1. RDBMS</p> 
   <div class="figure"> 
    <img alt="../_images/image2.1.png" src="../_images/image2.1.png"> 
   </div> 
   <p>图 2.2. 用图实现RDBMS模型</p> 
   <div class="figure"> 
    <img alt="../_images/image2.2.png" src="../_images/image2.2.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="key-value"> 
 <h2>2.2.2. 从图数据库转换成Key-Value数据库<a class="headerlink" href="#key-value" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>Key-Value模型适合用于简单的数据或者列表。当数据之间不断交互关联时，你更需要一张图模型。Neo4j让你能惊醒制作简单的数据结构到复杂，互相连接的数据。</p> 
   <p>图 2.3. Key-Value 存储模型</p> 
   <div class="figure"> 
    <img alt="../_images/image2.3.png" src="../_images/image2.3.png"> 
   </div> 
   <p>K* 代表一个键，V* 代表一个值。请注意，某些键指向其他键以及普通值。</p> 
   <p>图 2.4. 用图实现 Key-Value 模型</p> 
   <div class="figure"> 
    <img alt="../_images/image2.4.png" src="../_images/image2.4.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id2"> 
 <h2>2.2.3. 从图数据库转换成列数据库<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   列式（大表）数据库是 Key-Value模型的升级，用 “”来允许行数据增加。如果存储一张图，这个表将是分层的，关系也是非常明确的。
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>2.2.4. 从图数据库转换成文档型数据库<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>文档型数据库用文档进行层次划分，而自由的数据规划也很容易被表示成一颗树。成长为一张图的话，文档之间的关联你需要更有代表性的数据结构来存储，而在Neo4j中，这些关系是非常容易处理的。</p> 
   <p>图 2.5. 文档型数据库</p> 
   <div class="figure"> 
    <img alt="../_images/image2.5.png" src="../_images/image2.5.png"> 
   </div> 
   <p>D=文档, S=子文档, V=值, D2/S2 = 关联到（其他）文档的索引。</p> 
   <p>图 2.6. 从图数据库转换成文档型数据库</p> 
   <div class="figure"> 
    <img alt="../_images/image2.6.png" src="../_images/image2.6.png"> 
   </div> 
  </div>
 </blockquote> 
</div>
<h2>2.2.1. 从图数据库转换成 RDBMS<a class="headerlink" href="#rdbms" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>将所有的数据用竖立的堆栈表示，并且保持他们直接的关系，你可以看到下面一张图。一个 RDBMS 被优化用于聚合数据，而Neo4j擅长于高度关联的数据。</p> 
  <p>图 2.1. RDBMS</p> 
  <div class="figure"> 
   <img alt="../_images/image2.1.png" src="../_images/image2.1.png"> 
  </div> 
  <p>图 2.2. 用图实现RDBMS模型</p> 
  <div class="figure"> 
   <img alt="../_images/image2.2.png" src="../_images/image2.2.png"> 
  </div> 
 </div>
</blockquote>
<h2>2.2.2. 从图数据库转换成Key-Value数据库<a class="headerlink" href="#key-value" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>Key-Value模型适合用于简单的数据或者列表。当数据之间不断交互关联时，你更需要一张图模型。Neo4j让你能惊醒制作简单的数据结构到复杂，互相连接的数据。</p> 
  <p>图 2.3. Key-Value 存储模型</p> 
  <div class="figure"> 
   <img alt="../_images/image2.3.png" src="../_images/image2.3.png"> 
  </div> 
  <p>K* 代表一个键，V* 代表一个值。请注意，某些键指向其他键以及普通值。</p> 
  <p>图 2.4. 用图实现 Key-Value 模型</p> 
  <div class="figure"> 
   <img alt="../_images/image2.4.png" src="../_images/image2.4.png"> 
  </div> 
 </div>
</blockquote>
<h2>2.2.3. 从图数据库转换成列数据库<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  列式（大表）数据库是 Key-Value模型的升级，用 “”来允许行数据增加。如果存储一张图，这个表将是分层的，关系也是非常明确的。
 </div>
</blockquote>
<h2>2.2.4. 从图数据库转换成文档型数据库<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>文档型数据库用文档进行层次划分，而自由的数据规划也很容易被表示成一颗树。成长为一张图的话，文档之间的关联你需要更有代表性的数据结构来存储，而在Neo4j中，这些关系是非常容易处理的。</p> 
  <p>图 2.5. 文档型数据库</p> 
  <div class="figure"> 
   <img alt="../_images/image2.5.png" src="../_images/image2.5.png"> 
  </div> 
  <p>D=文档, S=子文档, V=值, D2/S2 = 关联到（其他）文档的索引。</p> 
  <p>图 2.6. 从图数据库转换成文档型数据库</p> 
  <div class="figure"> 
   <img alt="../_images/image2.6.png" src="../_images/image2.6.png"> 
  </div> 
 </div>
</blockquote><span id="chapter3-index"></span>
<h1>第 3 章 Neo4j图数据库<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  这个章节将讲述Neo4j模型和行为的更多细节。
 </div>
</blockquote> 
<div class="section" id="id1"> 
 <h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
   </div> 
   <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id2"> 
 <h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
   </div> 
   <div class="figure"> 
    <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
   </div> 
   <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
   </div> 
   <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
   </div> 
   <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
   <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
   <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
   </div> 
   <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
   <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
   <p>表 3.1. 使用到的关系和关系类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="49%"> 
     <col width="51%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">功能</th> 
      <th class="head">实现</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get who a person follows</td> 
      <td>outgoing follows relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get the followers of a person</td> 
      <td>incoming follows relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get who a person blocks outgoing</td> 
      <td>blocks relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get who a person is blocked by</td> 
      <td>incoming blocks relationships, depth one</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
   </div> 
   <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="47%"> 
     <col width="53%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">What</th> 
      <th class="head">How</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get the full path of a file</td> 
      <td>incoming file relationships</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all paths for a file</td> 
      <td>incoming file and symbolic link relationships</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory</td> 
      <td>outgoing file and symbolic link relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all files in a directory, excluding symbolic links</td> 
      <td>outgoing file relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory, recursively</td> 
      <td>outgoing file and symbolic link relationships</td> 
     </tr> 
    </tbody> 
   </table> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
   <dl class="docutils"> 
    <dt>
     注意
    </dt> 
    <dd>
     null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
    </dd> 
   </dl> 
   <div class="figure"> 
    <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
   </div> 
   <p>表 3.2. 属性值类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="5%"> 
     <col width="45%"> 
     <col width="50%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">Type</th> 
      <th class="head">Description</th> 
      <th class="head">Value range</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>boolean</td> 
      <td>true/false</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>byte</td> 
      <td>8-bit integer</td> 
      <td>-128 to 127, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>short</td> 
      <td>16-bit integer</td> 
      <td>-32768 to 32767, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>int</td> 
      <td>32-bit integer</td> 
      <td>-2147483648 to 2147483647, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>long</td> 
      <td>64-bit integer</td> 
      <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>float</td> 
      <td>32-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-even">
      <td>double</td> 
      <td>64-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>char</td> 
      <td>16-bit unsigned integers representing Unicode characters</td> 
      <td>u0000 to uffff (0 to 65535)</td> 
     </tr> 
     <tr class="row-even">
      <td>String</td> 
      <td>sequence of Unicode characters</td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
   </div> 
   <p>最短的路径是0长度的像下面这样：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
   </div> 
   <p>长度为1的路径如下:</p> 
   <div class="figure"> 
    <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="traversal"> 
 <h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
   <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
   <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
   <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
   <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
  </div>
 </blockquote> 
</div>
<h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
  </div> 
  <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
  </div> 
  <div class="figure"> 
   <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
  </div> 
  <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
  </div> 
  <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
  </div> 
  <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
  <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
  <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
  </div> 
  <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
  <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
  <p>表 3.1. 使用到的关系和关系类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="49%"> 
    <col width="51%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">功能</th> 
     <th class="head">实现</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get who a person follows</td> 
     <td>outgoing follows relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get the followers of a person</td> 
     <td>incoming follows relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get who a person blocks outgoing</td> 
     <td>blocks relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get who a person is blocked by</td> 
     <td>incoming blocks relationships, depth one</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
  </div> 
  <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="47%"> 
    <col width="53%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">What</th> 
     <th class="head">How</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get the full path of a file</td> 
     <td>incoming file relationships</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all paths for a file</td> 
     <td>incoming file and symbolic link relationships</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory</td> 
     <td>outgoing file and symbolic link relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all files in a directory, excluding symbolic links</td> 
     <td>outgoing file relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory, recursively</td> 
     <td>outgoing file and symbolic link relationships</td> 
    </tr> 
   </tbody> 
  </table> 
 </div>
</blockquote>
<h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
  <dl class="docutils"> 
   <dt>
    注意
   </dt> 
   <dd>
    null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
   </dd> 
  </dl> 
  <div class="figure"> 
   <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
  </div> 
  <p>表 3.2. 属性值类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="5%"> 
    <col width="45%"> 
    <col width="50%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">Type</th> 
     <th class="head">Description</th> 
     <th class="head">Value range</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>boolean</td> 
     <td>true/false</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>byte</td> 
     <td>8-bit integer</td> 
     <td>-128 to 127, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>short</td> 
     <td>16-bit integer</td> 
     <td>-32768 to 32767, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>int</td> 
     <td>32-bit integer</td> 
     <td>-2147483648 to 2147483647, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>long</td> 
     <td>64-bit integer</td> 
     <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>float</td> 
     <td>32-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-even">
     <td>double</td> 
     <td>64-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>char</td> 
     <td>16-bit unsigned integers representing Unicode characters</td> 
     <td>u0000 to uffff (0 to 65535)</td> 
    </tr> 
    <tr class="row-even">
     <td>String</td> 
     <td>sequence of Unicode characters</td> 
     <td>&nbsp;</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
 </div>
</blockquote>
<h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
  </div> 
  <p>最短的路径是0长度的像下面这样：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
  </div> 
  <p>长度为1的路径如下:</p> 
  <div class="figure"> 
   <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
  <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
  <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
  <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
  <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
 </div>
</blockquote><span id="chapter3-index"></span>
<h1>第 3 章 Neo4j图数据库<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  这个章节将讲述Neo4j模型和行为的更多细节。
 </div>
</blockquote> 
<div class="section" id="id1"> 
 <h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
   </div> 
   <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id2"> 
 <h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
   </div> 
   <div class="figure"> 
    <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
   </div> 
   <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
   </div> 
   <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
   </div> 
   <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
   <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
   <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
   </div> 
   <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
   <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
   <p>表 3.1. 使用到的关系和关系类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="49%"> 
     <col width="51%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">功能</th> 
      <th class="head">实现</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get who a person follows</td> 
      <td>outgoing follows relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get the followers of a person</td> 
      <td>incoming follows relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get who a person blocks outgoing</td> 
      <td>blocks relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get who a person is blocked by</td> 
      <td>incoming blocks relationships, depth one</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
   </div> 
   <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="47%"> 
     <col width="53%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">What</th> 
      <th class="head">How</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get the full path of a file</td> 
      <td>incoming file relationships</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all paths for a file</td> 
      <td>incoming file and symbolic link relationships</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory</td> 
      <td>outgoing file and symbolic link relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all files in a directory, excluding symbolic links</td> 
      <td>outgoing file relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory, recursively</td> 
      <td>outgoing file and symbolic link relationships</td> 
     </tr> 
    </tbody> 
   </table> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
   <dl class="docutils"> 
    <dt>
     注意
    </dt> 
    <dd>
     null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
    </dd> 
   </dl> 
   <div class="figure"> 
    <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
   </div> 
   <p>表 3.2. 属性值类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="5%"> 
     <col width="45%"> 
     <col width="50%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">Type</th> 
      <th class="head">Description</th> 
      <th class="head">Value range</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>boolean</td> 
      <td>true/false</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>byte</td> 
      <td>8-bit integer</td> 
      <td>-128 to 127, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>short</td> 
      <td>16-bit integer</td> 
      <td>-32768 to 32767, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>int</td> 
      <td>32-bit integer</td> 
      <td>-2147483648 to 2147483647, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>long</td> 
      <td>64-bit integer</td> 
      <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>float</td> 
      <td>32-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-even">
      <td>double</td> 
      <td>64-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>char</td> 
      <td>16-bit unsigned integers representing Unicode characters</td> 
      <td>u0000 to uffff (0 to 65535)</td> 
     </tr> 
     <tr class="row-even">
      <td>String</td> 
      <td>sequence of Unicode characters</td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
   </div> 
   <p>最短的路径是0长度的像下面这样：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
   </div> 
   <p>长度为1的路径如下:</p> 
   <div class="figure"> 
    <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="traversal"> 
 <h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
   <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
   <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
   <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
   <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
  </div>
 </blockquote> 
</div>
<h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
  </div> 
  <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
  </div> 
  <div class="figure"> 
   <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
  </div> 
  <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
  </div> 
  <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
  </div> 
  <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
  <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
  <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
  </div> 
  <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
  <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
  <p>表 3.1. 使用到的关系和关系类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="49%"> 
    <col width="51%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">功能</th> 
     <th class="head">实现</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get who a person follows</td> 
     <td>outgoing follows relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get the followers of a person</td> 
     <td>incoming follows relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get who a person blocks outgoing</td> 
     <td>blocks relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get who a person is blocked by</td> 
     <td>incoming blocks relationships, depth one</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
  </div> 
  <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="47%"> 
    <col width="53%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">What</th> 
     <th class="head">How</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get the full path of a file</td> 
     <td>incoming file relationships</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all paths for a file</td> 
     <td>incoming file and symbolic link relationships</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory</td> 
     <td>outgoing file and symbolic link relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all files in a directory, excluding symbolic links</td> 
     <td>outgoing file relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory, recursively</td> 
     <td>outgoing file and symbolic link relationships</td> 
    </tr> 
   </tbody> 
  </table> 
 </div>
</blockquote>
<h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
  <dl class="docutils"> 
   <dt>
    注意
   </dt> 
   <dd>
    null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
   </dd> 
  </dl> 
  <div class="figure"> 
   <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
  </div> 
  <p>表 3.2. 属性值类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="5%"> 
    <col width="45%"> 
    <col width="50%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">Type</th> 
     <th class="head">Description</th> 
     <th class="head">Value range</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>boolean</td> 
     <td>true/false</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>byte</td> 
     <td>8-bit integer</td> 
     <td>-128 to 127, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>short</td> 
     <td>16-bit integer</td> 
     <td>-32768 to 32767, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>int</td> 
     <td>32-bit integer</td> 
     <td>-2147483648 to 2147483647, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>long</td> 
     <td>64-bit integer</td> 
     <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>float</td> 
     <td>32-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-even">
     <td>double</td> 
     <td>64-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>char</td> 
     <td>16-bit unsigned integers representing Unicode characters</td> 
     <td>u0000 to uffff (0 to 65535)</td> 
    </tr> 
    <tr class="row-even">
     <td>String</td> 
     <td>sequence of Unicode characters</td> 
     <td>&nbsp;</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
 </div>
</blockquote>
<h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
  </div> 
  <p>最短的路径是0长度的像下面这样：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
  </div> 
  <p>长度为1的路径如下:</p> 
  <div class="figure"> 
   <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
  <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
  <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
  <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
  <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
 </div>
</blockquote><span id="chapter3-index"></span>
<h1>第 3 章 Neo4j图数据库<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  这个章节将讲述Neo4j模型和行为的更多细节。
 </div>
</blockquote> 
<div class="section" id="id1"> 
 <h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
   </div> 
   <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id2"> 
 <h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
   </div> 
   <div class="figure"> 
    <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
   </div> 
   <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
   </div> 
   <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
   </div> 
   <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
   <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
   <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
   </div> 
   <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
   <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
   <p>表 3.1. 使用到的关系和关系类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="49%"> 
     <col width="51%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">功能</th> 
      <th class="head">实现</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get who a person follows</td> 
      <td>outgoing follows relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get the followers of a person</td> 
      <td>incoming follows relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get who a person blocks outgoing</td> 
      <td>blocks relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get who a person is blocked by</td> 
      <td>incoming blocks relationships, depth one</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
   </div> 
   <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="47%"> 
     <col width="53%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">What</th> 
      <th class="head">How</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get the full path of a file</td> 
      <td>incoming file relationships</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all paths for a file</td> 
      <td>incoming file and symbolic link relationships</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory</td> 
      <td>outgoing file and symbolic link relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all files in a directory, excluding symbolic links</td> 
      <td>outgoing file relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory, recursively</td> 
      <td>outgoing file and symbolic link relationships</td> 
     </tr> 
    </tbody> 
   </table> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
   <dl class="docutils"> 
    <dt>
     注意
    </dt> 
    <dd>
     null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
    </dd> 
   </dl> 
   <div class="figure"> 
    <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
   </div> 
   <p>表 3.2. 属性值类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="5%"> 
     <col width="45%"> 
     <col width="50%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">Type</th> 
      <th class="head">Description</th> 
      <th class="head">Value range</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>boolean</td> 
      <td>true/false</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>byte</td> 
      <td>8-bit integer</td> 
      <td>-128 to 127, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>short</td> 
      <td>16-bit integer</td> 
      <td>-32768 to 32767, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>int</td> 
      <td>32-bit integer</td> 
      <td>-2147483648 to 2147483647, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>long</td> 
      <td>64-bit integer</td> 
      <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>float</td> 
      <td>32-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-even">
      <td>double</td> 
      <td>64-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>char</td> 
      <td>16-bit unsigned integers representing Unicode characters</td> 
      <td>u0000 to uffff (0 to 65535)</td> 
     </tr> 
     <tr class="row-even">
      <td>String</td> 
      <td>sequence of Unicode characters</td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
   </div> 
   <p>最短的路径是0长度的像下面这样：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
   </div> 
   <p>长度为1的路径如下:</p> 
   <div class="figure"> 
    <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="traversal"> 
 <h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
   <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
   <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
   <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
   <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
  </div>
 </blockquote> 
</div>
<h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
  </div> 
  <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
  </div> 
  <div class="figure"> 
   <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
  </div> 
  <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
  </div> 
  <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
  </div> 
  <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
  <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
  <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
  </div> 
  <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
  <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
  <p>表 3.1. 使用到的关系和关系类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="49%"> 
    <col width="51%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">功能</th> 
     <th class="head">实现</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get who a person follows</td> 
     <td>outgoing follows relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get the followers of a person</td> 
     <td>incoming follows relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get who a person blocks outgoing</td> 
     <td>blocks relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get who a person is blocked by</td> 
     <td>incoming blocks relationships, depth one</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
  </div> 
  <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="47%"> 
    <col width="53%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">What</th> 
     <th class="head">How</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get the full path of a file</td> 
     <td>incoming file relationships</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all paths for a file</td> 
     <td>incoming file and symbolic link relationships</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory</td> 
     <td>outgoing file and symbolic link relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all files in a directory, excluding symbolic links</td> 
     <td>outgoing file relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory, recursively</td> 
     <td>outgoing file and symbolic link relationships</td> 
    </tr> 
   </tbody> 
  </table> 
 </div>
</blockquote>
<h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
  <dl class="docutils"> 
   <dt>
    注意
   </dt> 
   <dd>
    null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
   </dd> 
  </dl> 
  <div class="figure"> 
   <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
  </div> 
  <p>表 3.2. 属性值类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="5%"> 
    <col width="45%"> 
    <col width="50%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">Type</th> 
     <th class="head">Description</th> 
     <th class="head">Value range</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>boolean</td> 
     <td>true/false</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>byte</td> 
     <td>8-bit integer</td> 
     <td>-128 to 127, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>short</td> 
     <td>16-bit integer</td> 
     <td>-32768 to 32767, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>int</td> 
     <td>32-bit integer</td> 
     <td>-2147483648 to 2147483647, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>long</td> 
     <td>64-bit integer</td> 
     <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>float</td> 
     <td>32-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-even">
     <td>double</td> 
     <td>64-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>char</td> 
     <td>16-bit unsigned integers representing Unicode characters</td> 
     <td>u0000 to uffff (0 to 65535)</td> 
    </tr> 
    <tr class="row-even">
     <td>String</td> 
     <td>sequence of Unicode characters</td> 
     <td>&nbsp;</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
 </div>
</blockquote>
<h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
  </div> 
  <p>最短的路径是0长度的像下面这样：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
  </div> 
  <p>长度为1的路径如下:</p> 
  <div class="figure"> 
   <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
  <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
  <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
  <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
  <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
 </div>
</blockquote><span id="chapter3-index"></span>
<h1>第 3 章 Neo4j图数据库<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  这个章节将讲述Neo4j模型和行为的更多细节。
 </div>
</blockquote> 
<div class="section" id="id1"> 
 <h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
   </div> 
   <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id2"> 
 <h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
   </div> 
   <div class="figure"> 
    <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
   </div> 
   <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
   </div> 
   <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
   </div> 
   <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
   <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
   <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
   </div> 
   <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
   <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
   <p>表 3.1. 使用到的关系和关系类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="49%"> 
     <col width="51%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">功能</th> 
      <th class="head">实现</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get who a person follows</td> 
      <td>outgoing follows relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get the followers of a person</td> 
      <td>incoming follows relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get who a person blocks outgoing</td> 
      <td>blocks relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get who a person is blocked by</td> 
      <td>incoming blocks relationships, depth one</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
   </div> 
   <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="47%"> 
     <col width="53%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">What</th> 
      <th class="head">How</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get the full path of a file</td> 
      <td>incoming file relationships</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all paths for a file</td> 
      <td>incoming file and symbolic link relationships</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory</td> 
      <td>outgoing file and symbolic link relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all files in a directory, excluding symbolic links</td> 
      <td>outgoing file relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory, recursively</td> 
      <td>outgoing file and symbolic link relationships</td> 
     </tr> 
    </tbody> 
   </table> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
   <dl class="docutils"> 
    <dt>
     注意
    </dt> 
    <dd>
     null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
    </dd> 
   </dl> 
   <div class="figure"> 
    <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
   </div> 
   <p>表 3.2. 属性值类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="5%"> 
     <col width="45%"> 
     <col width="50%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">Type</th> 
      <th class="head">Description</th> 
      <th class="head">Value range</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>boolean</td> 
      <td>true/false</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>byte</td> 
      <td>8-bit integer</td> 
      <td>-128 to 127, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>short</td> 
      <td>16-bit integer</td> 
      <td>-32768 to 32767, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>int</td> 
      <td>32-bit integer</td> 
      <td>-2147483648 to 2147483647, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>long</td> 
      <td>64-bit integer</td> 
      <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>float</td> 
      <td>32-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-even">
      <td>double</td> 
      <td>64-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>char</td> 
      <td>16-bit unsigned integers representing Unicode characters</td> 
      <td>u0000 to uffff (0 to 65535)</td> 
     </tr> 
     <tr class="row-even">
      <td>String</td> 
      <td>sequence of Unicode characters</td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
   </div> 
   <p>最短的路径是0长度的像下面这样：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
   </div> 
   <p>长度为1的路径如下:</p> 
   <div class="figure"> 
    <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="traversal"> 
 <h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
   <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
   <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
   <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
   <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
  </div>
 </blockquote> 
</div>
<h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
  </div> 
  <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
  </div> 
  <div class="figure"> 
   <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
  </div> 
  <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
  </div> 
  <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
  </div> 
  <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
  <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
  <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
  </div> 
  <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
  <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
  <p>表 3.1. 使用到的关系和关系类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="49%"> 
    <col width="51%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">功能</th> 
     <th class="head">实现</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get who a person follows</td> 
     <td>outgoing follows relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get the followers of a person</td> 
     <td>incoming follows relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get who a person blocks outgoing</td> 
     <td>blocks relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get who a person is blocked by</td> 
     <td>incoming blocks relationships, depth one</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
  </div> 
  <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="47%"> 
    <col width="53%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">What</th> 
     <th class="head">How</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get the full path of a file</td> 
     <td>incoming file relationships</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all paths for a file</td> 
     <td>incoming file and symbolic link relationships</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory</td> 
     <td>outgoing file and symbolic link relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all files in a directory, excluding symbolic links</td> 
     <td>outgoing file relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory, recursively</td> 
     <td>outgoing file and symbolic link relationships</td> 
    </tr> 
   </tbody> 
  </table> 
 </div>
</blockquote>
<h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
  <dl class="docutils"> 
   <dt>
    注意
   </dt> 
   <dd>
    null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
   </dd> 
  </dl> 
  <div class="figure"> 
   <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
  </div> 
  <p>表 3.2. 属性值类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="5%"> 
    <col width="45%"> 
    <col width="50%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">Type</th> 
     <th class="head">Description</th> 
     <th class="head">Value range</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>boolean</td> 
     <td>true/false</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>byte</td> 
     <td>8-bit integer</td> 
     <td>-128 to 127, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>short</td> 
     <td>16-bit integer</td> 
     <td>-32768 to 32767, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>int</td> 
     <td>32-bit integer</td> 
     <td>-2147483648 to 2147483647, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>long</td> 
     <td>64-bit integer</td> 
     <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>float</td> 
     <td>32-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-even">
     <td>double</td> 
     <td>64-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>char</td> 
     <td>16-bit unsigned integers representing Unicode characters</td> 
     <td>u0000 to uffff (0 to 65535)</td> 
    </tr> 
    <tr class="row-even">
     <td>String</td> 
     <td>sequence of Unicode characters</td> 
     <td>&nbsp;</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
 </div>
</blockquote>
<h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
  </div> 
  <p>最短的路径是0长度的像下面这样：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
  </div> 
  <p>长度为1的路径如下:</p> 
  <div class="figure"> 
   <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
  <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
  <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
  <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
  <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
 </div>
</blockquote><span id="chapter3-index"></span>
<h1>第 3 章 Neo4j图数据库<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  这个章节将讲述Neo4j模型和行为的更多细节。
 </div>
</blockquote> 
<div class="section" id="id1"> 
 <h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
   </div> 
   <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id2"> 
 <h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
   </div> 
   <div class="figure"> 
    <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
   </div> 
   <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
   </div> 
   <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
   </div> 
   <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
   <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
   <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
   </div> 
   <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
   <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
   <p>表 3.1. 使用到的关系和关系类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="49%"> 
     <col width="51%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">功能</th> 
      <th class="head">实现</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get who a person follows</td> 
      <td>outgoing follows relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get the followers of a person</td> 
      <td>incoming follows relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get who a person blocks outgoing</td> 
      <td>blocks relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get who a person is blocked by</td> 
      <td>incoming blocks relationships, depth one</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
   </div> 
   <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="47%"> 
     <col width="53%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">What</th> 
      <th class="head">How</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get the full path of a file</td> 
      <td>incoming file relationships</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all paths for a file</td> 
      <td>incoming file and symbolic link relationships</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory</td> 
      <td>outgoing file and symbolic link relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all files in a directory, excluding symbolic links</td> 
      <td>outgoing file relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory, recursively</td> 
      <td>outgoing file and symbolic link relationships</td> 
     </tr> 
    </tbody> 
   </table> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
   <dl class="docutils"> 
    <dt>
     注意
    </dt> 
    <dd>
     null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
    </dd> 
   </dl> 
   <div class="figure"> 
    <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
   </div> 
   <p>表 3.2. 属性值类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="5%"> 
     <col width="45%"> 
     <col width="50%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">Type</th> 
      <th class="head">Description</th> 
      <th class="head">Value range</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>boolean</td> 
      <td>true/false</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>byte</td> 
      <td>8-bit integer</td> 
      <td>-128 to 127, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>short</td> 
      <td>16-bit integer</td> 
      <td>-32768 to 32767, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>int</td> 
      <td>32-bit integer</td> 
      <td>-2147483648 to 2147483647, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>long</td> 
      <td>64-bit integer</td> 
      <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>float</td> 
      <td>32-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-even">
      <td>double</td> 
      <td>64-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>char</td> 
      <td>16-bit unsigned integers representing Unicode characters</td> 
      <td>u0000 to uffff (0 to 65535)</td> 
     </tr> 
     <tr class="row-even">
      <td>String</td> 
      <td>sequence of Unicode characters</td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
   </div> 
   <p>最短的路径是0长度的像下面这样：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
   </div> 
   <p>长度为1的路径如下:</p> 
   <div class="figure"> 
    <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="traversal"> 
 <h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
   <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
   <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
   <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
   <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
  </div>
 </blockquote> 
</div>
<h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
  </div> 
  <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
  </div> 
  <div class="figure"> 
   <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
  </div> 
  <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
  </div> 
  <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
  </div> 
  <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
  <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
  <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
  </div> 
  <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
  <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
  <p>表 3.1. 使用到的关系和关系类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="49%"> 
    <col width="51%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">功能</th> 
     <th class="head">实现</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get who a person follows</td> 
     <td>outgoing follows relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get the followers of a person</td> 
     <td>incoming follows relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get who a person blocks outgoing</td> 
     <td>blocks relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get who a person is blocked by</td> 
     <td>incoming blocks relationships, depth one</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
  </div> 
  <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="47%"> 
    <col width="53%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">What</th> 
     <th class="head">How</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get the full path of a file</td> 
     <td>incoming file relationships</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all paths for a file</td> 
     <td>incoming file and symbolic link relationships</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory</td> 
     <td>outgoing file and symbolic link relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all files in a directory, excluding symbolic links</td> 
     <td>outgoing file relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory, recursively</td> 
     <td>outgoing file and symbolic link relationships</td> 
    </tr> 
   </tbody> 
  </table> 
 </div>
</blockquote>
<h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
  <dl class="docutils"> 
   <dt>
    注意
   </dt> 
   <dd>
    null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
   </dd> 
  </dl> 
  <div class="figure"> 
   <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
  </div> 
  <p>表 3.2. 属性值类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="5%"> 
    <col width="45%"> 
    <col width="50%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">Type</th> 
     <th class="head">Description</th> 
     <th class="head">Value range</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>boolean</td> 
     <td>true/false</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>byte</td> 
     <td>8-bit integer</td> 
     <td>-128 to 127, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>short</td> 
     <td>16-bit integer</td> 
     <td>-32768 to 32767, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>int</td> 
     <td>32-bit integer</td> 
     <td>-2147483648 to 2147483647, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>long</td> 
     <td>64-bit integer</td> 
     <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>float</td> 
     <td>32-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-even">
     <td>double</td> 
     <td>64-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>char</td> 
     <td>16-bit unsigned integers representing Unicode characters</td> 
     <td>u0000 to uffff (0 to 65535)</td> 
    </tr> 
    <tr class="row-even">
     <td>String</td> 
     <td>sequence of Unicode characters</td> 
     <td>&nbsp;</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
 </div>
</blockquote>
<h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
  </div> 
  <p>最短的路径是0长度的像下面这样：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
  </div> 
  <p>长度为1的路径如下:</p> 
  <div class="figure"> 
   <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
  <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
  <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
  <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
  <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
 </div>
</blockquote><span id="chapter3-index"></span>
<h1>第 3 章 Neo4j图数据库<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  这个章节将讲述Neo4j模型和行为的更多细节。
 </div>
</blockquote> 
<div class="section" id="id1"> 
 <h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
   </div> 
   <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id2"> 
 <h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
   </div> 
   <div class="figure"> 
    <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
   </div> 
   <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
   </div> 
   <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
   </div> 
   <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
   <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
   <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
   </div> 
   <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
   <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
   <p>表 3.1. 使用到的关系和关系类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="49%"> 
     <col width="51%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">功能</th> 
      <th class="head">实现</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get who a person follows</td> 
      <td>outgoing follows relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get the followers of a person</td> 
      <td>incoming follows relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get who a person blocks outgoing</td> 
      <td>blocks relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get who a person is blocked by</td> 
      <td>incoming blocks relationships, depth one</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
   </div> 
   <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="47%"> 
     <col width="53%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">What</th> 
      <th class="head">How</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>get the full path of a file</td> 
      <td>incoming file relationships</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all paths for a file</td> 
      <td>incoming file and symbolic link relationships</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory</td> 
      <td>outgoing file and symbolic link relationships, depth one</td> 
     </tr> 
     <tr class="row-odd">
      <td>get all files in a directory, excluding symbolic links</td> 
      <td>outgoing file relationships, depth one</td> 
     </tr> 
     <tr class="row-even">
      <td>get all files in a directory, recursively</td> 
      <td>outgoing file and symbolic link relationships</td> 
     </tr> 
    </tbody> 
   </table> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
   <dl class="docutils"> 
    <dt>
     注意
    </dt> 
    <dd>
     null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
    </dd> 
   </dl> 
   <div class="figure"> 
    <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
   </div> 
   <p>表 3.2. 属性值类型</p> 
   <table border="1" class="docutils"> 
    <colgroup> 
     <col width="5%"> 
     <col width="45%"> 
     <col width="50%"> 
    </colgroup> 
    <thead valign="bottom"> 
     <tr class="row-odd">
      <th class="head">Type</th> 
      <th class="head">Description</th> 
      <th class="head">Value range</th> 
     </tr> 
    </thead> 
    <tbody valign="top"> 
     <tr class="row-even">
      <td>boolean</td> 
      <td>true/false</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>byte</td> 
      <td>8-bit integer</td> 
      <td>-128 to 127, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>short</td> 
      <td>16-bit integer</td> 
      <td>-32768 to 32767, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>int</td> 
      <td>32-bit integer</td> 
      <td>-2147483648 to 2147483647, inclusive</td> 
     </tr> 
     <tr class="row-even">
      <td>long</td> 
      <td>64-bit integer</td> 
      <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
     </tr> 
     <tr class="row-odd">
      <td>float</td> 
      <td>32-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-even">
      <td>double</td> 
      <td>64-bit IEEE 754 floating-point number</td> 
      <td>&nbsp;</td> 
     </tr> 
     <tr class="row-odd">
      <td>char</td> 
      <td>16-bit unsigned integers representing Unicode characters</td> 
      <td>u0000 to uffff (0 to 65535)</td> 
     </tr> 
     <tr class="row-even">
      <td>String</td> 
      <td>sequence of Unicode characters</td> 
      <td>&nbsp;</td> 
     </tr> 
    </tbody> 
   </table> 
   <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
   <div class="figure"> 
    <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
   </div> 
   <p>最短的路径是0长度的像下面这样：</p> 
   <div class="figure"> 
    <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
   </div> 
   <p>长度为1的路径如下:</p> 
   <div class="figure"> 
    <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="traversal"> 
 <h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
   <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
   <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
   <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
   <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
  </div>
 </blockquote> 
</div>
<h2>3.1. 节点<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>构成一张图的基本元素是节点和关系。在Neo4j中，节点和关系都可以包含属性。 节点经常被用于表示一些实体，但依赖关系也一样可以表示实体。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.1.png" src="../_images/image3.1.png"> 
  </div> 
  <p>下面让我们认识一个最简单的节点，他只有一个属性，属性名是name,属性值是Marko：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.2.png" src="../_images/image3.2.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.2. 关系<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点之间的关系是图数据库很重要的一部分。通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.3.png" src="../_images/image3.3.png"> 
  </div> 
  <div class="figure"> 
   <img alt="../_images/image3.4.png" src="../_images/image3.4.png"> 
  </div> 
  <p>一个关系连接两个节点，必须有一个开始节点和结束节点。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.5.png" src="../_images/image3.5.png"> 
  </div> 
  <p>因为关系总是直接相连的，所以对于一个节点来说，与他关联的关系看起来有输入/输出两个方向，这个特性对于我们遍历图非常有帮助：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.6.png" src="../_images/image3.6.png"> 
  </div> 
  <p>关系在任一方向都会被遍历访问。这意味着我们并不需要在不同方向都新增关系。</p> 
  <p>而关系总是会有一个方向，所以当这个方向对你的应用没有意义时你可以忽略方向。</p> 
  <p>特别注意一个节点可以有一个关系是指向自己的：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.7.png" src="../_images/image3.7.png"> 
  </div> 
  <p>为了将来增强遍历图中所有的关系，我们需要为关系设置类型。注意 关键字 type 在这可能会被误解，你其实可以把他简单的理解为一个标签而已。</p> 
  <p>下面的例子是一个有两种关系的最简单的社会化网络图。</p> 
  <p>表 3.1. 使用到的关系和关系类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="49%"> 
    <col width="51%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">功能</th> 
     <th class="head">实现</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get who a person follows</td> 
     <td>outgoing follows relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get the followers of a person</td> 
     <td>incoming follows relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get who a person blocks outgoing</td> 
     <td>blocks relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get who a person is blocked by</td> 
     <td>incoming blocks relationships, depth one</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>下面的放里是一个简单的文件系统，包括一些符号软链接：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.8.png" src="../_images/image3.8.png"> 
  </div> 
  <p>根据你看到的，你在遍历的时候会用到关系的方向和关系的类型。</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="47%"> 
    <col width="53%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">What</th> 
     <th class="head">How</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>get the full path of a file</td> 
     <td>incoming file relationships</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all paths for a file</td> 
     <td>incoming file and symbolic link relationships</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory</td> 
     <td>outgoing file and symbolic link relationships, depth one</td> 
    </tr> 
    <tr class="row-odd">
     <td>get all files in a directory, excluding symbolic links</td> 
     <td>outgoing file relationships, depth one</td> 
    </tr> 
    <tr class="row-even">
     <td>get all files in a directory, recursively</td> 
     <td>outgoing file and symbolic link relationships</td> 
    </tr> 
   </tbody> 
  </table> 
 </div>
</blockquote>
<h2>3.3. 属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>节点和关系都可以设置自己的属性。 属性是由Key-Value键值对组成，键名是字符串。属性值是要么是原始值，要么是原始值类型的一个数组。比如+String+，+int+和i+int[]+都是合法的。</p> 
  <dl class="docutils"> 
   <dt>
    注意
   </dt> 
   <dd>
    null不是一个合法的属性值。 Nulls能代替模仿一个不存在的Key。
   </dd> 
  </dl> 
  <div class="figure"> 
   <img alt="../_images/image3.9.png" src="../_images/image3.9.png"> 
  </div> 
  <p>表 3.2. 属性值类型</p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="5%"> 
    <col width="45%"> 
    <col width="50%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">Type</th> 
     <th class="head">Description</th> 
     <th class="head">Value range</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>boolean</td> 
     <td>true/false</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>byte</td> 
     <td>8-bit integer</td> 
     <td>-128 to 127, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>short</td> 
     <td>16-bit integer</td> 
     <td>-32768 to 32767, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>int</td> 
     <td>32-bit integer</td> 
     <td>-2147483648 to 2147483647, inclusive</td> 
    </tr> 
    <tr class="row-even">
     <td>long</td> 
     <td>64-bit integer</td> 
     <td>-9223372036854775808 to 9223372036854775807, inclusive</td> 
    </tr> 
    <tr class="row-odd">
     <td>float</td> 
     <td>32-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-even">
     <td>double</td> 
     <td>64-bit IEEE 754 floating-point number</td> 
     <td>&nbsp;</td> 
    </tr> 
    <tr class="row-odd">
     <td>char</td> 
     <td>16-bit unsigned integers representing Unicode characters</td> 
     <td>u0000 to uffff (0 to 65535)</td> 
    </tr> 
    <tr class="row-even">
     <td>String</td> 
     <td>sequence of Unicode characters</td> 
     <td>&nbsp;</td> 
    </tr> 
   </tbody> 
  </table> 
  <p>如果要了解float/double类型的更多细节，请参考：Java Language Specification。</p> 
 </div>
</blockquote>
<h2>3.4. 路径<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果。</p> 
  <div class="figure"> 
   <img alt="../_images/image3.10.png" src="../_images/image3.10.png"> 
  </div> 
  <p>最短的路径是0长度的像下面这样：</p> 
  <div class="figure"> 
   <img alt="../_images/image3.11.png" src="../_images/image3.11.png"> 
  </div> 
  <p>长度为1的路径如下:</p> 
  <div class="figure"> 
   <img alt="../_images/image3.12.png" src="../_images/image3.12.png"> 
  </div> 
 </div>
</blockquote>
<h2>3.5. 遍历（Traversal）<a class="headerlink" href="#traversal" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>遍历一张图就是按照一定的规则，跟随他们的关系，访问关联的的节点集合。最多的情况是只有一部分子图被访问到，因为你知道你对那一部分节点或者关系感兴趣。</p> 
  <p>Neo4j提供了遍历的API，可以让你指定遍历规则。最简单的设置就是设置遍历是宽度优先还是深度优先。</p> 
  <p>想对遍历框架有一个深入的了解，请参考章节：tutorial-traversal。</p> 
  <p>想了解更多的Java代码范例，请参考章节：tutorials-java-embedded-traversal。</p> 
  <p>其他查询图的方式还有cypher-query-lang, Cypher和gremlin-plugin, Gremlin。</p> 
 </div>
</blockquote><span id="chapter4index"></span>
<h1>第 4 章 在Java应用中使用Neo4j<a class="headerlink" href="#javaneo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>在Java中采用嵌入方式使用Neo4j是非常方便的。在这个章节中，你将找到所有你想了解的 — 从基本环境的搭建到用你的数据做一些实际有用的事情。</p> 
  <p>在Java应用中使用Neo4j是非常容易的。正这个章节中你将找到你需要的一切—从开发环境的建立到用你的数据做一些有用的事情。</p> 
 </div>
</blockquote> 
<div class="toctree-wrapper compound"> 
 <ul> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_1.html">4.1. 将Neo4j引入到你的项目工程中</a>
   <ul> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_1.html#id1">4.1.1. 增加Neo4j的库文件到构造路径中</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_1.html#id2">4.1.2. 将Neo4j作为一个依赖添加</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_1.html#id3">4.1.3. 启动和停止</a></li> 
   </ul> </li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_2.html">4.2. 你好，世界</a>
   <ul> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_2.html#id2">4.2.1. 准备图数据库</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_2.html#id3">4.2.2. 在一个事务中完成多次写数据库操作</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_2.html#id4">4.2.3. 创建一个小型图数据库</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_2.html#id5">4.2.4. 打印结果</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_2.html#id6">4.2.5. 移除数据</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_2.html#id7">4.2.6. 关闭图数据库</a></li> 
   </ul> </li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_3.html">4.3. 带索引的用户数据库</a></li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_4.html">4.4. 基本的单元测试</a></li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_5.html">4.5. 遍历查询</a>
   <ul> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_5.html#id2">4.5.1. 黑客帝国</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_5.html#api">4.5.2. 老的遍历查询 API</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_5.html#id3">4.5.3. 在遍历查询中的唯一路径</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_5.html#id4">4.5.4. 社交网络</a></li> 
   </ul> </li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_6.html">4.6. 领域实体</a></li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_7.html">4.7. 图算法范例</a></li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_8.html">4.8. 读取一个管理配置属性</a></li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_9.html">4.9. OSGi配置</a>
   <ul> 
    <li class="toctree-l2"><a class="reference internal" href="chapter4_9.html#simple-osgi-activator">4.9.1. Simple OSGi Activator 脚本</a></li> 
   </ul> </li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter4_10.html">4.10. 在Java中执行Cypher查询</a></li> 
 </ul> 
</div><span id="chapter4-1-index"></span>
<h1>4.1. 将Neo4j引入到你的项目工程中<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  在选择了适合你的平台的editions,edition后，只需要引入Neo4j的jars 文件到你的工程的构造路径中，你就可以在你的工程中使用Neo4j数据库了。下面的章节将展示如何完成引入，要么通过直接改变构造路径，要么使用包依赖管理。
 </div>
</blockquote> 
<div class="section" id="id1"> 
 <h2>4.1.1. 增加Neo4j的库文件到构造路径中<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>可以通过下面任意一种方式得到需要的jar文件:</p> 
   <ul class="simple"> 
    <li>解压 Neo4j 下载的压缩包，我们需要使用的jars文件都包括在lib目录中。</li> 
    <li>直接使用Maven中心仓库的jars文件。</li> 
   </ul> 
   <p>将jars引入到你的项目工程中:</p> 
   <p><strong>JDK tools</strong></p> 
   <blockquote> 
    <div>
     增加到 -classpath 中
    </div>
   </blockquote> 
   <p><strong>Eclipse</strong></p> 
   <ul class="simple"> 
    <li>右键点击工程然后选择 Build Path → Configure Build Path 。在对话框中选择 Add External JARs ，浏览到Neo4j的’lib/’目录并选择所有的jar文件。</li> 
    <li>另外一种方式是使用 User Libraries。</li> 
   </ul> 
   <p><strong>IntelliJ IDEA</strong></p> 
   <blockquote> 
    <div>
     看 Libraries, Global Libraries, and the Configure Library dialog了解详情。
    </div>
   </blockquote> 
   <p><strong>NetBeans</strong></p> 
   <ul class="simple"> 
    <li>在工程的 Libraries 点击鼠标右键，选择 Add JAR/Folder ，浏览到Neo4j的’lib/’目录选择里面的所有jar文件。</li> 
    <li>你也可以从工程节点来管理库文件。详细情况请查看管理一个工程的classpath。</li> 
   </ul> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id2"> 
 <h2>4.1.2. 将Neo4j作为一个依赖添加<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>想总览一下主要的Neo4j构件，请查看editions。列在里面的构件都是包含实际Neo4j实现的顶级构件。</p> 
   <p>你既可以使用顶级构件也可以直接引入单个的组件。在这的范例使用的是顶级构件的方式。</p> 
   <p><strong>Maven</strong></p> 
   <blockquote> 
    <div>
     <cite>Maven dependency.</cite>
    </div>
   </blockquote> 
   <div class="highlight-xml">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="nt">&lt;project&gt;</span> 
... 
 <span class="nt">&lt;dependencies&gt;</span> 
  <span class="nt">&lt;dependency&gt;</span> 
   <span class="nt">&lt;groupId&gt;</span>org.neo4j<span class="nt">&lt;/groupId&gt;</span> 
   <span class="nt">&lt;artifactId&gt;</span>neo4j<span class="nt">&lt;/artifactId&gt;</span> 
   <span class="nt">&lt;version&gt;</span>1.8<span class="nt">&lt;/version&gt;</span> 
  <span class="nt">&lt;/dependency&gt;</span> 
  ... 
 <span class="nt">&lt;/dependencies&gt;</span> 
... 
<span class="nt">&lt;/project&gt;</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>参数 <code class="docutils literal"><span class="pre">artifactId</span></code> 可以在 <cite>editions</cite> 找到。</p> 
   <p><strong>Eclipse and Maven</strong></p> 
   <blockquote> 
    <div>
     <p>在Eclipse中开发，推荐安装插件 <cite>m2e plugin</cite> 让Maven管理classpath来代替上面的方案。</p> 
     <p>这样的话，你既可以通过Maven命令行来编译你的工程，也可以通过Maven命令自动生成一个Eclipse工作环境以便进行开发。</p> 
    </div>
   </blockquote> 
   <p><strong>Ivy</strong></p> 
   <blockquote> 
    <div>
     <p>确保能解决来自Maven Central的依赖问题，比如我们在你的 <cite>ivysettings.xml</cite> 文件中使用下面的配置选项：</p> 
     <div class="highlight-xml">
      <table class="highlighttable">
       <tbody>
        <tr>
         <td class="linenos">
          <div class="linenodiv">
           <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre>
          </div></td>
         <td class="code">
          <div class="highlight">
           <pre><span></span><span class="nt">&lt;ivysettings&gt;</span> 
  <span class="nt">&lt;settings</span> <span class="na">defaultResolver=</span><span class="s">"main"</span><span class="nt">/&gt;</span> 
  <span class="nt">&lt;resolvers&gt;</span> 
    <span class="nt">&lt;chain</span> <span class="na">name=</span><span class="s">"main"</span><span class="nt">&gt;</span> 
      <span class="nt">&lt;filesystem</span> <span class="na">name=</span><span class="s">"local"</span><span class="nt">&gt;</span> 
        <span class="nt">&lt;artifact</span> <span class="na">pattern=</span><span class="s">"${ivy.settings.dir}/repository/[artifact]-[revision].[ext]"</span> <span class="nt">/&gt;</span> 
      <span class="nt">&lt;/filesystem&gt;</span> 
      <span class="nt">&lt;ibiblio</span> <span class="na">name=</span><span class="s">"maven_central"</span> <span class="na">root=</span><span class="s">"http://repo1.maven.org/maven2/"</span> <span class="na">m2compatible=</span><span class="s">"true"</span><span class="nt">/&gt;</span> 
    <span class="nt">&lt;/chain&gt;</span> 
  <span class="nt">&lt;/resolvers&gt;</span> 
<span class="nt">&lt;/ivysettings&gt;</span>
</pre>
          </div> </td>
        </tr>
       </tbody>
      </table>
     </div> 
     <p>有了这个，你就可以通过增加下面这些内容到你的 <cite>ivy.xml</cite> 中来引入Neo4j：</p> 
     <div class="highlight-xml">
      <table class="highlighttable">
       <tbody>
        <tr>
         <td class="linenos">
          <div class="linenodiv">
           <pre>1
2
3
4
5</pre>
          </div></td>
         <td class="code">
          <div class="highlight">
           <pre><span></span><span class="nt">&lt;dependencies&gt;</span> 
  .. 
  <span class="nt">&lt;dependency</span> <span class="na">org=</span><span class="s">"org.neo4j"</span> <span class="na">name=</span><span class="s">"neo4j"</span> <span class="na">rev=</span><span class="s">"1.8"</span><span class="nt">/&gt;</span> 
  .. 
<span class="nt">&lt;/dependencies&gt;</span>
</pre>
          </div> </td>
        </tr>
       </tbody>
      </table>
     </div> 
     <p>参数 <code class="docutils literal"><span class="pre">name</span></code> 可以在`editions`找到。</p> 
    </div>
   </blockquote> 
   <p><strong>Gradle</strong></p> 
   <blockquote> 
    <div>
     <p>下面的范例演示了用Gradle生成一个脚本来引入Neo4j库文件。</p> 
     <div class="highlight-python">
      <table class="highlighttable">
       <tbody>
        <tr>
         <td class="linenos">
          <div class="linenodiv">
           <pre>1
2
3
4
5
6
7
8</pre>
          </div></td>
         <td class="code">
          <div class="highlight">
           <pre><span></span><span class="k">def</span> <span class="nf">neo4jVersion</span> <span class="o">=</span> <span class="s2">"1.8"</span>
<span class="nb">apply</span> <span class="n">plugin</span><span class="p">:</span> <span class="s1">'java'</span>
<span class="n">repositories</span> <span class="p">{</span> 
   <span class="n">mavenCentral</span><span class="p">()</span> 
<span class="p">}</span> 
<span class="n">dependencies</span> <span class="p">{</span> 
   <span class="nb">compile</span> <span class="s2">"org.neo4j:neo4j:${neo4jVersion}"</span>
<span class="p">}</span>
</pre>
          </div> </td>
        </tr>
       </tbody>
      </table>
     </div> 
     <p>参数 <code class="docutils literal"><span class="pre">coordinates</span></code> (在范例中的 <code class="docutils literal"><span class="pre">org.neo4j:neo4j</span></code> ) 可以在 <cite>editions</cite> 找到。</p> 
    </div>
   </blockquote> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>4.1.3. 启动和停止<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>为了创建一个新的数据库或者打开一个已经存在的，你需要实例化一个 <cite>EmbeddedGraphDatabase</cite> 对象：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">graphDb</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">()</span><span class="o">.</span><span class="n">newEmbeddedDatabase</span><span class="p">(</span> <span class="n">DB_PATH</span> <span class="p">);</span> 
<span class="n">registerShutdownHook</span><span class="p">(</span> <span class="n">graphDb</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p><cite>EmbeddedGraphDatabase</cite> 实例可以在多个线程中共享。然而你不能创建多个实例来指向同一个数据库。</p> 
   <p>为了停止数据库，你需要调用方法 <cite>shutdown()</cite> ：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">graphDb</span><span class="o">.</span><span class="n">shutdown</span><span class="p">();</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>为了确保Neo4j被正确关闭，你可以为它增加一个关闭钩子方法：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">void</span> <span class="n">registerShutdownHook</span><span class="p">(</span> <span class="n">final</span> <span class="n">GraphDatabaseService</span> <span class="n">graphDb</span> <span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Registers</span> <span class="n">a</span> <span class="n">shutdown</span> <span class="n">hook</span> <span class="k">for</span> <span class="n">the</span> <span class="n">Neo4j</span> <span class="n">instance</span> <span class="n">so</span> <span class="n">that</span> <span class="n">it</span>
    <span class="o">//</span> <span class="n">shuts</span> <span class="n">down</span> <span class="n">nicely</span> <span class="n">when</span> <span class="n">the</span> <span class="n">VM</span> <span class="n">exits</span> <span class="p">(</span><span class="n">even</span> <span class="k">if</span> <span class="n">you</span> <span class="s2">"Ctrl-C"</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">running</span> <span class="n">example</span> <span class="n">before</span> <span class="n">it</span><span class="s1">'s completed)</span>
    <span class="n">Runtime</span><span class="o">.</span><span class="n">getRuntime</span><span class="p">()</span><span class="o">.</span><span class="n">addShutdownHook</span><span class="p">(</span> <span class="n">new</span> <span class="n">Thread</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nd">@Override</span>
        <span class="n">public</span> <span class="n">void</span> <span class="n">run</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">graphDb</span><span class="o">.</span><span class="n">shutdown</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>如果你只想通过 只读方式 浏览数据库，请使用 <cite>EmbeddedReadOnlyGraphDatabase</cite> 。</p> 
   <p>想通过配置设置来启动Neo4j，一个Neo4j属性文件可以像下面这样加载：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">GraphDatabaseService</span> <span class="n">graphDb</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">()</span><span class="o">.</span>
    <span class="n">newEmbeddedDatabaseBuilder</span><span class="p">(</span> <span class="s2">"target/database/location"</span> <span class="p">)</span><span class="o">.</span>
    <span class="n">loadPropertiesFromFile</span><span class="p">(</span> <span class="n">pathToConfig</span> <span class="o">+</span> <span class="s2">"neo4j.properties"</span> <span class="p">)</span><span class="o">.</span>
    <span class="n">newGraphDatabase</span><span class="p">();</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>或者你可以编程创建你自己的 <cite>Map&lt;String, String&gt;</cite> 来代替。</p> 
   <p>想了解更多配置设置的细节，请参考: <cite>embedded-configuration</cite> 。</p> 
  </div>
 </blockquote> 
</div>
<h2>4.1.1. 增加Neo4j的库文件到构造路径中<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>可以通过下面任意一种方式得到需要的jar文件:</p> 
  <ul class="simple"> 
   <li>解压 Neo4j 下载的压缩包，我们需要使用的jars文件都包括在lib目录中。</li> 
   <li>直接使用Maven中心仓库的jars文件。</li> 
  </ul> 
  <p>将jars引入到你的项目工程中:</p> 
  <p><strong>JDK tools</strong></p> 
  <blockquote> 
   <div>
    增加到 -classpath 中
   </div>
  </blockquote> 
  <p><strong>Eclipse</strong></p> 
  <ul class="simple"> 
   <li>右键点击工程然后选择 Build Path → Configure Build Path 。在对话框中选择 Add External JARs ，浏览到Neo4j的’lib/’目录并选择所有的jar文件。</li> 
   <li>另外一种方式是使用 User Libraries。</li> 
  </ul> 
  <p><strong>IntelliJ IDEA</strong></p> 
  <blockquote> 
   <div>
    看 Libraries, Global Libraries, and the Configure Library dialog了解详情。
   </div>
  </blockquote> 
  <p><strong>NetBeans</strong></p> 
  <ul class="simple"> 
   <li>在工程的 Libraries 点击鼠标右键，选择 Add JAR/Folder ，浏览到Neo4j的’lib/’目录选择里面的所有jar文件。</li> 
   <li>你也可以从工程节点来管理库文件。详细情况请查看管理一个工程的classpath。</li> 
  </ul> 
 </div>
</blockquote>
<h2>4.1.2. 将Neo4j作为一个依赖添加<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>想总览一下主要的Neo4j构件，请查看editions。列在里面的构件都是包含实际Neo4j实现的顶级构件。</p> 
  <p>你既可以使用顶级构件也可以直接引入单个的组件。在这的范例使用的是顶级构件的方式。</p> 
  <p><strong>Maven</strong></p> 
  <blockquote> 
   <div>
    <cite>Maven dependency.</cite>
   </div>
  </blockquote> 
  <div class="highlight-xml">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="nt">&lt;project&gt;</span> 
... 
 <span class="nt">&lt;dependencies&gt;</span> 
  <span class="nt">&lt;dependency&gt;</span> 
   <span class="nt">&lt;groupId&gt;</span>org.neo4j<span class="nt">&lt;/groupId&gt;</span> 
   <span class="nt">&lt;artifactId&gt;</span>neo4j<span class="nt">&lt;/artifactId&gt;</span> 
   <span class="nt">&lt;version&gt;</span>1.8<span class="nt">&lt;/version&gt;</span> 
  <span class="nt">&lt;/dependency&gt;</span> 
  ... 
 <span class="nt">&lt;/dependencies&gt;</span> 
... 
<span class="nt">&lt;/project&gt;</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>参数 <code class="docutils literal"><span class="pre">artifactId</span></code> 可以在 <cite>editions</cite> 找到。</p> 
  <p><strong>Eclipse and Maven</strong></p> 
  <blockquote> 
   <div>
    <p>在Eclipse中开发，推荐安装插件 <cite>m2e plugin</cite> 让Maven管理classpath来代替上面的方案。</p> 
    <p>这样的话，你既可以通过Maven命令行来编译你的工程，也可以通过Maven命令自动生成一个Eclipse工作环境以便进行开发。</p> 
   </div>
  </blockquote> 
  <p><strong>Ivy</strong></p> 
  <blockquote> 
   <div>
    <p>确保能解决来自Maven Central的依赖问题，比如我们在你的 <cite>ivysettings.xml</cite> 文件中使用下面的配置选项：</p> 
    <div class="highlight-xml">
     <table class="highlighttable">
      <tbody>
       <tr>
        <td class="linenos">
         <div class="linenodiv">
          <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre>
         </div></td>
        <td class="code">
         <div class="highlight">
          <pre><span></span><span class="nt">&lt;ivysettings&gt;</span> 
  <span class="nt">&lt;settings</span> <span class="na">defaultResolver=</span><span class="s">"main"</span><span class="nt">/&gt;</span> 
  <span class="nt">&lt;resolvers&gt;</span> 
    <span class="nt">&lt;chain</span> <span class="na">name=</span><span class="s">"main"</span><span class="nt">&gt;</span> 
      <span class="nt">&lt;filesystem</span> <span class="na">name=</span><span class="s">"local"</span><span class="nt">&gt;</span> 
        <span class="nt">&lt;artifact</span> <span class="na">pattern=</span><span class="s">"${ivy.settings.dir}/repository/[artifact]-[revision].[ext]"</span> <span class="nt">/&gt;</span> 
      <span class="nt">&lt;/filesystem&gt;</span> 
      <span class="nt">&lt;ibiblio</span> <span class="na">name=</span><span class="s">"maven_central"</span> <span class="na">root=</span><span class="s">"http://repo1.maven.org/maven2/"</span> <span class="na">m2compatible=</span><span class="s">"true"</span><span class="nt">/&gt;</span> 
    <span class="nt">&lt;/chain&gt;</span> 
  <span class="nt">&lt;/resolvers&gt;</span> 
<span class="nt">&lt;/ivysettings&gt;</span>
</pre>
         </div> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>有了这个，你就可以通过增加下面这些内容到你的 <cite>ivy.xml</cite> 中来引入Neo4j：</p> 
    <div class="highlight-xml">
     <table class="highlighttable">
      <tbody>
       <tr>
        <td class="linenos">
         <div class="linenodiv">
          <pre>1
2
3
4
5</pre>
         </div></td>
        <td class="code">
         <div class="highlight">
          <pre><span></span><span class="nt">&lt;dependencies&gt;</span> 
  .. 
  <span class="nt">&lt;dependency</span> <span class="na">org=</span><span class="s">"org.neo4j"</span> <span class="na">name=</span><span class="s">"neo4j"</span> <span class="na">rev=</span><span class="s">"1.8"</span><span class="nt">/&gt;</span> 
  .. 
<span class="nt">&lt;/dependencies&gt;</span>
</pre>
         </div> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>参数 <code class="docutils literal"><span class="pre">name</span></code> 可以在`editions`找到。</p> 
   </div>
  </blockquote> 
  <p><strong>Gradle</strong></p> 
  <blockquote> 
   <div>
    <p>下面的范例演示了用Gradle生成一个脚本来引入Neo4j库文件。</p> 
    <div class="highlight-python">
     <table class="highlighttable">
      <tbody>
       <tr>
        <td class="linenos">
         <div class="linenodiv">
          <pre>1
2
3
4
5
6
7
8</pre>
         </div></td>
        <td class="code">
         <div class="highlight">
          <pre><span></span><span class="k">def</span> <span class="nf">neo4jVersion</span> <span class="o">=</span> <span class="s2">"1.8"</span>
<span class="nb">apply</span> <span class="n">plugin</span><span class="p">:</span> <span class="s1">'java'</span>
<span class="n">repositories</span> <span class="p">{</span> 
   <span class="n">mavenCentral</span><span class="p">()</span> 
<span class="p">}</span> 
<span class="n">dependencies</span> <span class="p">{</span> 
   <span class="nb">compile</span> <span class="s2">"org.neo4j:neo4j:${neo4jVersion}"</span>
<span class="p">}</span>
</pre>
         </div> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>参数 <code class="docutils literal"><span class="pre">coordinates</span></code> (在范例中的 <code class="docutils literal"><span class="pre">org.neo4j:neo4j</span></code> ) 可以在 <cite>editions</cite> 找到。</p> 
   </div>
  </blockquote> 
 </div>
</blockquote>
<h2>4.1.3. 启动和停止<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>为了创建一个新的数据库或者打开一个已经存在的，你需要实例化一个 <cite>EmbeddedGraphDatabase</cite> 对象：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">graphDb</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">()</span><span class="o">.</span><span class="n">newEmbeddedDatabase</span><span class="p">(</span> <span class="n">DB_PATH</span> <span class="p">);</span> 
<span class="n">registerShutdownHook</span><span class="p">(</span> <span class="n">graphDb</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p><cite>EmbeddedGraphDatabase</cite> 实例可以在多个线程中共享。然而你不能创建多个实例来指向同一个数据库。</p> 
  <p>为了停止数据库，你需要调用方法 <cite>shutdown()</cite> ：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">graphDb</span><span class="o">.</span><span class="n">shutdown</span><span class="p">();</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>为了确保Neo4j被正确关闭，你可以为它增加一个关闭钩子方法：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">void</span> <span class="n">registerShutdownHook</span><span class="p">(</span> <span class="n">final</span> <span class="n">GraphDatabaseService</span> <span class="n">graphDb</span> <span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Registers</span> <span class="n">a</span> <span class="n">shutdown</span> <span class="n">hook</span> <span class="k">for</span> <span class="n">the</span> <span class="n">Neo4j</span> <span class="n">instance</span> <span class="n">so</span> <span class="n">that</span> <span class="n">it</span>
    <span class="o">//</span> <span class="n">shuts</span> <span class="n">down</span> <span class="n">nicely</span> <span class="n">when</span> <span class="n">the</span> <span class="n">VM</span> <span class="n">exits</span> <span class="p">(</span><span class="n">even</span> <span class="k">if</span> <span class="n">you</span> <span class="s2">"Ctrl-C"</span> <span class="n">the</span>
    <span class="o">//</span> <span class="n">running</span> <span class="n">example</span> <span class="n">before</span> <span class="n">it</span><span class="s1">'s completed)</span>
    <span class="n">Runtime</span><span class="o">.</span><span class="n">getRuntime</span><span class="p">()</span><span class="o">.</span><span class="n">addShutdownHook</span><span class="p">(</span> <span class="n">new</span> <span class="n">Thread</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nd">@Override</span>
        <span class="n">public</span> <span class="n">void</span> <span class="n">run</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">graphDb</span><span class="o">.</span><span class="n">shutdown</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>如果你只想通过 只读方式 浏览数据库，请使用 <cite>EmbeddedReadOnlyGraphDatabase</cite> 。</p> 
  <p>想通过配置设置来启动Neo4j，一个Neo4j属性文件可以像下面这样加载：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">GraphDatabaseService</span> <span class="n">graphDb</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">()</span><span class="o">.</span>
    <span class="n">newEmbeddedDatabaseBuilder</span><span class="p">(</span> <span class="s2">"target/database/location"</span> <span class="p">)</span><span class="o">.</span>
    <span class="n">loadPropertiesFromFile</span><span class="p">(</span> <span class="n">pathToConfig</span> <span class="o">+</span> <span class="s2">"neo4j.properties"</span> <span class="p">)</span><span class="o">.</span>
    <span class="n">newGraphDatabase</span><span class="p">();</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>或者你可以编程创建你自己的 <cite>Map&lt;String, String&gt;</cite> 来代替。</p> 
  <p>想了解更多配置设置的细节，请参考: <cite>embedded-configuration</cite> 。</p> 
 </div>
</blockquote><span id="id1"></span>
<h1>4.2. 你好，世界<a class="headerlink" href="#chapter4-2-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>正这里可以学习如何创建和访问节点和关系。关于建立工程环境的信息，请参考：<a class="reference internal" href="chapter4_1.html#chapter4-1-index"><span class="std std-ref">第 4.1 节 将Neo4j引入到你的项目工程中</span></a>。</p> 
  <p>从 <a class="reference internal" href="../chapter2/chapter2_1.html#chapter2-1-index"><span class="std std-ref">第 2.1 节 什么是图数据库</span></a> 中，我们还记得，一个Neo4j图数据库由以下几部分组成：</p> 
  <ul class="simple"> 
   <li>相互关联的节点</li> 
   <li>有一定的关系存在</li> 
   <li>在节点和关系上面有一些属性。</li> 
  </ul> 
  <p>所有的关系都有一个类型。比如，如果一个图数据库实例表示一个社网络，那么一个关系类型可能叫 KNOWS 。</p> 
  <p>如果一个类型叫 KNOWS 的关系连接了两个节点，那么这可能表示这两个人呼吸认识。一个图数据库中大量的语义都被编码成关系的类型来使用。虽然关系是直接相连的，但他们也可以不用考虑他们遍历的方向而互相遍历对方。</p> 
  <p><strong>提示</strong></p> 
  <blockquote> 
   <div>
    范例源代码下载地址：
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/EmbeddedNeo4j.java">EmbeddedNeo4j.java</a>
   </div>
  </blockquote> 
 </div>
</blockquote> 
<div class="section" id="id2"> 
 <h2>4.2.1. 准备图数据库<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>关系类型可以通过 enum 创建。正这个范例中我们之需要一个单独的关系类型。下面是我们的定义：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">enum</span> <span class="n">RelTypes</span> <span class="n">implements</span> <span class="n">RelationshipType</span> <span class="p">{</span>
    <span class="n">KNOWS</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>我们也准备一些需要用到的参数：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">GraphDatabaseService</span> <span class="n">graphDb</span><span class="p">;</span>
<span class="n">Node</span> <span class="n">firstNode</span><span class="p">;</span>
<span class="n">Node</span> <span class="n">secondNode</span><span class="p">;</span>
<span class="n">Relationship</span> <span class="n">relationship</span><span class="p">;</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>下一步将启动数据库服务器了。逐一如果给定的保持数据库的目录如果不存在，那么它会自动创建。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">graphDb</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">()</span><span class="o">.</span><span class="n">newEmbeddedDatabase</span><span class="p">(</span> <span class="n">DB_PATH</span> <span class="p">);</span>
<span class="n">registerShutdownHook</span><span class="p">(</span> <span class="n">graphDb</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>注意：启动一个图数据库是一个非常重（耗费资源）的操作，所以不要每次你需要与数据库进行交互操作时都去启动一个新的实例。这个实例可以被多个线程共享。事务是线程安全的。 就像你上面所看到的一样，我们注册了一个关闭数据库的钩子用来确保在JVM退出时数据库已经被关闭。现在是时候与数据库进行交互了。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>4.2.2. 在一个事务中完成多次写数据库操作<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>所有的写操作（创建，删除以及更新）都是在一个事务中完成的。这是一个有意的设计，因为我们相信事务是使用一个企业级数据库中非常重要的一部分。现在，在Neo4j中的事务处理是非常容易的：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7
8</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">Transaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">beginTx</span><span class="p">();</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Updating</span> <span class="n">operations</span> <span class="n">go</span> <span class="n">here</span>
    <span class="n">tx</span><span class="o">.</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">finally</span> <span class="p">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="n">finish</span><span class="p">();</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>要了解更多关于事务的细节，请参考：transactions 和 <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/Transaction.html">Java API中的事务接口</a>。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>4.2.3. 创建一个小型图数据库<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>现在，让我们来创建一些节点。 API是非常直观的。你也随意查看在 <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/">http://components.neo4j.org/neo4j/1.8/apidocs/</a> 的JavaDocs文档。它们也被包括正发行版中。这儿展示了如何创建一个小型图数据库，数据库中包括两个节点并用一个关系相连，节点和关系还包括一些属性：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">firstNode</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">firstNode</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"Hello, "</span> <span class="p">);</span>
<span class="n">secondNode</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">secondNode</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"World!"</span> <span class="p">);</span>

<span class="n">relationship</span> <span class="o">=</span> <span class="n">firstNode</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">secondNode</span><span class="p">,</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span> <span class="p">);</span>
<span class="n">relationship</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"brave Neo4j "</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>现在我们有一个图数据库看起来像下面这样：</p> 
   <p><cite>图 4.1. Hello World 图数据库</cite></p> 
   <div class="figure"> 
    <img alt="../_images/image4.1.png" src="../_images/image4.1.png"> 
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id5"> 
 <h2>4.2.4. 打印结果<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>在我们创建我们的图数据库后，让我们从中读取数据并打印结果。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="k">print</span><span class="p">(</span> <span class="n">firstNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"message"</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="k">print</span><span class="p">(</span> <span class="n">relationship</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"message"</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="k">print</span><span class="p">(</span> <span class="n">secondNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"message"</span> <span class="p">)</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>输出结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>Hello, brave Neo4j World!
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id6"> 
 <h2>4.2.5. 移除数据<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>在这种情况下我们将在提交之前移除数据：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="o">//</span> <span class="n">let</span><span class="s1">'s remove the data</span>
<span class="n">firstNode</span><span class="o">.</span><span class="n">getSingleRelationship</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">();</span>
<span class="n">firstNode</span><span class="o">.</span><span class="n">delete</span><span class="p">();</span>
<span class="n">secondNode</span><span class="o">.</span><span class="n">delete</span><span class="p">();</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>注意删除一个仍然有关系的节点，当事务提交是会失败。这是为了确保关系始终有一个开始节点和结束节点。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id7"> 
 <h2>4.2.6. 关闭图数据库<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>最后，当应用完成后 关闭数据库：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">graphDb</span><span class="o">.</span><span class="n">shutdown</span><span class="p">();</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
  </div>
 </blockquote> 
</div>
<h2>4.2.1. 准备图数据库<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>关系类型可以通过 enum 创建。正这个范例中我们之需要一个单独的关系类型。下面是我们的定义：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">enum</span> <span class="n">RelTypes</span> <span class="n">implements</span> <span class="n">RelationshipType</span> <span class="p">{</span>
    <span class="n">KNOWS</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>我们也准备一些需要用到的参数：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">GraphDatabaseService</span> <span class="n">graphDb</span><span class="p">;</span>
<span class="n">Node</span> <span class="n">firstNode</span><span class="p">;</span>
<span class="n">Node</span> <span class="n">secondNode</span><span class="p">;</span>
<span class="n">Relationship</span> <span class="n">relationship</span><span class="p">;</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>下一步将启动数据库服务器了。逐一如果给定的保持数据库的目录如果不存在，那么它会自动创建。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">graphDb</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">()</span><span class="o">.</span><span class="n">newEmbeddedDatabase</span><span class="p">(</span> <span class="n">DB_PATH</span> <span class="p">);</span>
<span class="n">registerShutdownHook</span><span class="p">(</span> <span class="n">graphDb</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>注意：启动一个图数据库是一个非常重（耗费资源）的操作，所以不要每次你需要与数据库进行交互操作时都去启动一个新的实例。这个实例可以被多个线程共享。事务是线程安全的。 就像你上面所看到的一样，我们注册了一个关闭数据库的钩子用来确保在JVM退出时数据库已经被关闭。现在是时候与数据库进行交互了。</p> 
 </div>
</blockquote>
<h2>4.2.2. 在一个事务中完成多次写数据库操作<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>所有的写操作（创建，删除以及更新）都是在一个事务中完成的。这是一个有意的设计，因为我们相信事务是使用一个企业级数据库中非常重要的一部分。现在，在Neo4j中的事务处理是非常容易的：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7
8</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Transaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">beginTx</span><span class="p">();</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Updating</span> <span class="n">operations</span> <span class="n">go</span> <span class="n">here</span>
    <span class="n">tx</span><span class="o">.</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">finally</span> <span class="p">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="n">finish</span><span class="p">();</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>要了解更多关于事务的细节，请参考：transactions 和 <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/Transaction.html">Java API中的事务接口</a>。</p> 
 </div>
</blockquote>
<h2>4.2.3. 创建一个小型图数据库<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>现在，让我们来创建一些节点。 API是非常直观的。你也随意查看在 <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/">http://components.neo4j.org/neo4j/1.8/apidocs/</a> 的JavaDocs文档。它们也被包括正发行版中。这儿展示了如何创建一个小型图数据库，数据库中包括两个节点并用一个关系相连，节点和关系还包括一些属性：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">firstNode</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">firstNode</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"Hello, "</span> <span class="p">);</span>
<span class="n">secondNode</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">secondNode</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"World!"</span> <span class="p">);</span>

<span class="n">relationship</span> <span class="o">=</span> <span class="n">firstNode</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">secondNode</span><span class="p">,</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span> <span class="p">);</span>
<span class="n">relationship</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"brave Neo4j "</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>现在我们有一个图数据库看起来像下面这样：</p> 
  <p><cite>图 4.1. Hello World 图数据库</cite></p> 
  <div class="figure"> 
   <img alt="../_images/image4.1.png" src="../_images/image4.1.png"> 
  </div> 
 </div>
</blockquote>
<h2>4.2.4. 打印结果<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>在我们创建我们的图数据库后，让我们从中读取数据并打印结果。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="k">print</span><span class="p">(</span> <span class="n">firstNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"message"</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="k">print</span><span class="p">(</span> <span class="n">relationship</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"message"</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="k">print</span><span class="p">(</span> <span class="n">secondNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"message"</span> <span class="p">)</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>输出结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>Hello, brave Neo4j World!
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote>
<h2>4.2.5. 移除数据<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>在这种情况下我们将在提交之前移除数据：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="o">//</span> <span class="n">let</span><span class="s1">'s remove the data</span>
<span class="n">firstNode</span><span class="o">.</span><span class="n">getSingleRelationship</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">)</span><span class="o">.</span><span class="n">delete</span><span class="p">();</span>
<span class="n">firstNode</span><span class="o">.</span><span class="n">delete</span><span class="p">();</span>
<span class="n">secondNode</span><span class="o">.</span><span class="n">delete</span><span class="p">();</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>注意删除一个仍然有关系的节点，当事务提交是会失败。这是为了确保关系始终有一个开始节点和结束节点。</p> 
 </div>
</blockquote>
<h2>4.2.6. 关闭图数据库<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>最后，当应用完成后 关闭数据库：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">graphDb</span><span class="o">.</span><span class="n">shutdown</span><span class="p">();</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote><span id="id1"></span>
<h1>4.3. 带索引的用户数据库<a class="headerlink" href="#chapter4-3-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>你有一个用户数据库，希望通过名称查找到用户。首先，下面这是我们想创建的数据库结构：</p> 
  <p><cite>图 4.2. 用户节点空间预览</cite></p> 
  <div class="figure"> 
   <img alt="../_images/image4.2.png" src="../_images/image4.2.png"> 
  </div> 
  <p>其中，参考节点连接了一个用户参考节点，而真实的所有用户都连接在用户参考节点上面。</p> 
  <p>提示</p> 
  <blockquote> 
   <div>
    范例中的源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/EmbeddedNeo4jWithIndexing.java">EmbeddedNeo4jWithIndexing.java</a>
   </div>
  </blockquote> 
  <p>首先，我们定义要用到的关系类型：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">enum</span> <span class="n">RelTypes</span> <span class="n">implements</span> <span class="n">RelationshipType</span> <span class="p">{</span>
    <span class="n">USERS_REFERENCE</span><span class="p">,</span>
    <span class="n">USER</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>然后，我们创建了两个辅助方法来处理用户名称以及往数据库新增用户：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">String</span> <span class="n">idToUserName</span><span class="p">(</span> <span class="n">final</span> <span class="nb">int</span> <span class="nb">id</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">"user"</span> <span class="o">+</span> <span class="nb">id</span> <span class="o">+</span> <span class="s2">"@neo4j.org"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">private</span> <span class="n">static</span> <span class="n">Node</span> <span class="n">createAndIndexUser</span><span class="p">(</span> <span class="n">final</span> <span class="n">String</span> <span class="n">username</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
    <span class="n">node</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="n">USERNAME_KEY</span><span class="p">,</span> <span class="n">username</span> <span class="p">);</span>
    <span class="n">nodeIndex</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">node</span><span class="p">,</span> <span class="n">USERNAME_KEY</span><span class="p">,</span> <span class="n">username</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>下一步我们将启动数据库:</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">graphDb</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">()</span><span class="o">.</span><span class="n">newEmbeddedDatabase</span><span class="p">(</span> <span class="n">DB_PATH</span> <span class="p">);</span>
<span class="n">nodeIndex</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">index</span><span class="p">()</span><span class="o">.</span><span class="n">forNodes</span><span class="p">(</span> <span class="s2">"nodes"</span> <span class="p">);</span>
<span class="n">registerShutdownHook</span><span class="p">();</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>是时候新增用户了：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Transaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">beginTx</span><span class="p">();</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">users</span> <span class="n">sub</span> <span class="n">reference</span> <span class="n">node</span>
    <span class="n">Node</span> <span class="n">usersReferenceNode</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
    <span class="n">graphDb</span><span class="o">.</span><span class="n">getReferenceNode</span><span class="p">()</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span>
        <span class="n">usersReferenceNode</span><span class="p">,</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">USERS_REFERENCE</span> <span class="p">);</span>
    <span class="o">//</span> <span class="n">Create</span> <span class="n">some</span> <span class="n">users</span> <span class="ow">and</span> <span class="n">index</span> <span class="n">their</span> <span class="n">names</span> <span class="k">with</span> <span class="n">the</span> <span class="n">IndexService</span>
    <span class="k">for</span> <span class="p">(</span> <span class="nb">int</span> <span class="nb">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nb">id</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nb">id</span><span class="o">++</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Node</span> <span class="n">userNode</span> <span class="o">=</span> <span class="n">createAndIndexUser</span><span class="p">(</span> <span class="n">idToUserName</span><span class="p">(</span> <span class="nb">id</span> <span class="p">)</span> <span class="p">);</span>
        <span class="n">usersReferenceNode</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">userNode</span><span class="p">,</span>
            <span class="n">RelTypes</span><span class="o">.</span><span class="n">USER</span> <span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>通过Id查找用户:</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="nb">int</span> <span class="n">idToFind</span> <span class="o">=</span> <span class="mi">45</span><span class="p">;</span>
<span class="n">Node</span> <span class="n">foundUser</span> <span class="o">=</span> <span class="n">nodeIndex</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">USERNAME_KEY</span><span class="p">,</span> <span class="n">idToUserName</span><span class="p">(</span> <span class="n">idToFind</span> <span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">getSingle</span><span class="p">();</span>
<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span> <span class="s2">"The username of user "</span> <span class="o">+</span> <span class="n">idToFind</span> <span class="o">+</span> <span class="s2">" is "</span> <span class="o">+</span> <span class="n">foundUser</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="n">USERNAME_KEY</span> <span class="p">)</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote><span id="id1"></span>
<h1>4.4. 基本的单元测试<a class="headerlink" href="#chapter4-4-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>Neo4j的单元测试的基本模式通过下面的范例来阐释。</p> 
  <p>要访问Neo4j测试功能，你应该把neo4j-kernel ‘tests.jar’新增到你的类路径中。你可以从Maven Central: <a class="reference external" href="http://search.maven.org/">org.neo4j:neo4j-kernel</a> 下载到需要的jars。</p> 
  <p>使用Maven作为一个依赖管理，你通常会正pom.xml中增加依赖配置：</p> 
  <div class="highlight-xml">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="nt">&lt;project&gt;</span>
...
    <span class="nt">&lt;dependencies&gt;</span>
     <span class="nt">&lt;dependency&gt;</span>
      <span class="nt">&lt;groupId&gt;</span>org.neo4j<span class="nt">&lt;/groupId&gt;</span>
      <span class="nt">&lt;artifactId&gt;</span>neo4j-kernel<span class="nt">&lt;/artifactId&gt;</span>
      <span class="nt">&lt;version&gt;</span>${neo4j-version}<span class="nt">&lt;/version&gt;</span>
      <span class="nt">&lt;type&gt;</span>test-jar<span class="nt">&lt;/type&gt;</span>
      <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
     <span class="nt">&lt;/dependency&gt;</span>
     ...
    <span class="nt">&lt;/dependencies&gt;</span>
...
<span class="nt">&lt;/project&gt;</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p><code class="docutils literal"><span class="pre">${neo4j-version}</span></code> 是Neo4j的版本号。</p> 
  <p>到此，我们已经准备好进行单元测试编码了。</p> 
  <p>提示</p> 
  <blockquote> 
   <div>
    范例源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/test/java/org/neo4j/examples/Neo4jBasicTest.java">Neo4jBasicTest.java</a>
   </div>
  </blockquote> 
  <p>每一次开始单元测试之前，请创建一个干净的数据库：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="nd">@Before</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">prepareTestDatabase</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">graphDb</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TestGraphDatabaseFactory</span><span class="p">()</span><span class="o">.</span><span class="n">newImpermanentDatabaseBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">newGraphDatabase</span><span class="p">();</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在测试完成之后，请关闭数据库：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="nd">@After</span>
<span class="n">public</span> <span class="n">void</span> <span class="n">destroyTestDatabase</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">graphDb</span><span class="o">.</span><span class="n">shutdown</span><span class="p">();</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在测试期间，创建节点并检查它们是否存在，并在一个事务中结束写操作。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Transaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">beginTx</span><span class="p">();</span>

<span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
    <span class="n">n</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"name"</span><span class="p">,</span> <span class="s2">"Nancy"</span> <span class="p">);</span>
    <span class="n">tx</span><span class="o">.</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">catch</span> <span class="p">(</span> <span class="ne">Exception</span> <span class="n">e</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="n">failure</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">finally</span>
<span class="p">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="n">finish</span><span class="p">();</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">node</span> <span class="n">should</span> <span class="n">have</span> <span class="n">an</span> <span class="nb">id</span> <span class="n">greater</span> <span class="n">than</span> <span class="mi">0</span><span class="p">,</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">the</span> <span class="nb">id</span> <span class="n">of</span> <span class="n">the</span>
<span class="o">//</span> <span class="n">reference</span> <span class="n">node</span><span class="o">.</span>
<span class="n">assertThat</span><span class="p">(</span> <span class="n">n</span><span class="o">.</span><span class="n">getId</span><span class="p">(),</span> <span class="ow">is</span><span class="p">(</span> <span class="n">greaterThan</span><span class="p">(</span> <span class="mi">0</span><span class="n">l</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Retrieve</span> <span class="n">a</span> <span class="n">node</span> <span class="n">by</span> <span class="n">using</span> <span class="n">the</span> <span class="nb">id</span> <span class="n">of</span> <span class="n">the</span> <span class="n">created</span> <span class="n">node</span><span class="o">.</span> <span class="n">The</span> <span class="nb">id</span><span class="s1">'s and</span>
<span class="o">//</span> <span class="nb">property</span> <span class="n">should</span> <span class="n">match</span><span class="o">.</span>
<span class="n">Node</span> <span class="n">foundNode</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">getNodeById</span><span class="p">(</span> <span class="n">n</span><span class="o">.</span><span class="n">getId</span><span class="p">()</span> <span class="p">);</span>
<span class="n">assertThat</span><span class="p">(</span> <span class="n">foundNode</span><span class="o">.</span><span class="n">getId</span><span class="p">(),</span> <span class="ow">is</span><span class="p">(</span> <span class="n">n</span><span class="o">.</span><span class="n">getId</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">assertThat</span><span class="p">(</span> <span class="p">(</span><span class="n">String</span><span class="p">)</span> <span class="n">foundNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">),</span> <span class="ow">is</span><span class="p">(</span> <span class="s2">"Nancy"</span> <span class="p">)</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>如果你想查看创建数据库的参数配置，你可以这样：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">config</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">config</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="s2">"neostore.nodestore.db.mapped_memory"</span><span class="p">,</span> <span class="s2">"10M"</span> <span class="p">);</span>
<span class="n">config</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="s2">"string_block_size"</span><span class="p">,</span> <span class="s2">"60"</span> <span class="p">);</span>
<span class="n">config</span><span class="o">.</span><span class="n">put</span><span class="p">(</span> <span class="s2">"array_block_size"</span><span class="p">,</span> <span class="s2">"300"</span> <span class="p">);</span>
<span class="n">GraphDatabaseService</span> <span class="n">db</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ImpermanentGraphDatabase</span><span class="p">(</span> <span class="n">config</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote><span id="id1"></span>
<h1>4.5. 遍历查询<a class="headerlink" href="#chapter4-5-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>了解更多关于遍历查询的信息，请参考：tutorial-traversal。</p> 
  <p>了解更多关于遍历查询范例的信息，请参考：<span class="xref std std-ref">第 7 章 数据模型范例</span> 。</p> 
 </div>
</blockquote> 
<div class="section" id="id2"> 
 <h2>4.5.1. 黑客帝国<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>对于上面的黑客帝国范例的遍历查询，这次使用新的遍历API：</p> 
   <p>提示</p> 
   <blockquote> 
    <div>
     范例源代码下载地址： 
     <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/NewMatrix.java">NewMatrix.java</a>
    </div>
   </blockquote> 
   <p>朋友以及朋友的朋友.</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">Traverser</span> <span class="n">getFriends</span><span class="p">(</span> <span class="n">final</span> <span class="n">Node</span> <span class="n">person</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">TraversalDescription</span> <span class="n">td</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
        <span class="o">.</span><span class="n">breadthFirst</span><span class="p">()</span>
        <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">excludeStartPosition</span><span class="p">()</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">td</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">person</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>让我们只想一次真实的遍历查询并打印结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="nb">int</span> <span class="n">numberOfFriends</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="n">neoNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"'s friends:</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="n">Traverser</span> <span class="n">friendsTraverser</span> <span class="o">=</span> <span class="n">getFriends</span><span class="p">(</span> <span class="n">neoNode</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">friendPath</span> <span class="p">:</span> <span class="n">friendsTraverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="s2">"At depth "</span> <span class="o">+</span> <span class="n">friendPath</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="s2">" =&gt; "</span>
              <span class="o">+</span> <span class="n">friendPath</span><span class="o">.</span><span class="n">endNode</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="n">numberOfFriends</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">+=</span> <span class="s2">"Number of friends found: "</span> <span class="o">+</span> <span class="n">numberOfFriends</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>输出结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>Thomas Anderson's friends:
At depth 1 =&gt; Trinity
At depth 1 =&gt; Morpheus
At depth 2 =&gt; Cypher
At depth 3 =&gt; Agent Smith
找到朋友的数量: 4
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>谁编写了黑客帝国？</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7
8
9</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">Traverser</span> <span class="n">findHackers</span><span class="p">(</span> <span class="n">final</span> <span class="n">Node</span> <span class="n">startNode</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">TraversalDescription</span> <span class="n">td</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
            <span class="o">.</span><span class="n">breadthFirst</span><span class="p">()</span>
            <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">CODED_BY</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">)</span>
            <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">)</span>
            <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span>
                    <span class="n">Evaluators</span><span class="o">.</span><span class="n">includeWhereLastRelationshipTypeIs</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">CODED_BY</span> <span class="p">)</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">td</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">startNode</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>打印输出结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="s2">"Hackers:</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">numberOfHackers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Traverser</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">findHackers</span><span class="p">(</span> <span class="n">getNeoNode</span><span class="p">()</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">hackerPath</span> <span class="p">:</span> <span class="n">traverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="s2">"At depth "</span> <span class="o">+</span> <span class="n">hackerPath</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="s2">" =&gt; "</span>
              <span class="o">+</span> <span class="n">hackerPath</span><span class="o">.</span><span class="n">endNode</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="n">numberOfHackers</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">+=</span> <span class="s2">"Number of hackers found: "</span> <span class="o">+</span> <span class="n">numberOfHackers</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>现在我们知道是谁编写了黑客帝国:</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>Hackers:
At depth 4 =&gt; The Architect
找到hackers的数量: 1
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>游走一个有序路径</p> 
   <p>这个范例展示了如何通过一个路径上下文控制一条路径的表现。</p> 
   <p>提示</p> 
   <blockquote> 
    <div>
     范例源代码下载地址： 
     <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/orderedpath/OrderedPath.java">OrderedPath.java</a>
    </div>
   </blockquote> 
   <p>创建一个图数据库.</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7
8</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">Node</span> <span class="n">A</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">B</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">C</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">D</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">A</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">B</span><span class="p">,</span> <span class="n">REL1</span> <span class="p">);</span>
<span class="n">B</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">C</span><span class="p">,</span> <span class="n">REL2</span> <span class="p">);</span>
<span class="n">C</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">D</span><span class="p">,</span> <span class="n">REL3</span> <span class="p">);</span>
<span class="n">A</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">C</span><span class="p">,</span> <span class="n">REL2</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <div class="figure"> 
    <img alt="../_images/image4.3.png" src="../_images/image4.3.png"> 
   </div> 
   <p>现在，关系 ( REL1 → REL2 → REL3 ) 的顺序保存在 一个 <code class="docutils literal"><span class="pre">ArrayList</span></code> 对象中。当遍历的时候，Evaluator 能针对它进行检查，确保只有拥有预定义关系顺序的路径才会被包括并返回：</p> 
   <p>定义如何游走这个路径.</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">final</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">RelationshipType</span><span class="o">&gt;</span> <span class="n">orderedPathContext</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">RelationshipType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">orderedPathContext</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">REL1</span> <span class="p">);</span>
<span class="n">orderedPathContext</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">withName</span><span class="p">(</span> <span class="s2">"REL2"</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">orderedPathContext</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">withName</span><span class="p">(</span> <span class="s2">"REL3"</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">TraversalDescription</span> <span class="n">td</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
    <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">new</span> <span class="n">Evaluator</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">@Override</span>
        <span class="n">public</span> <span class="n">Evaluation</span> <span class="n">evaluate</span><span class="p">(</span> <span class="n">final</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">Evaluation</span><span class="o">.</span><span class="n">EXCLUDE_AND_CONTINUE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">RelationshipType</span> <span class="n">expectedType</span> <span class="o">=</span> <span class="n">orderedPathContext</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
            <span class="n">boolean</span> <span class="n">isExpectedType</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">lastRelationship</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">isType</span><span class="p">(</span> <span class="n">expectedType</span> <span class="p">);</span>
            <span class="n">boolean</span> <span class="n">included</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="n">orderedPathContext</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
                               <span class="o">&amp;&amp;</span> <span class="n">isExpectedType</span><span class="p">;</span>
            <span class="n">boolean</span> <span class="n">continued</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">orderedPathContext</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
                                <span class="o">&amp;&amp;</span> <span class="n">isExpectedType</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">Evaluation</span><span class="o">.</span><span class="n">of</span><span class="p">(</span> <span class="n">included</span><span class="p">,</span> <span class="n">continued</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>执行一次遍历查询并返回结果.</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">Traverser</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">td</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">A</span> <span class="p">);</span>
<span class="n">PathPrinter</span> <span class="n">pathPrinter</span> <span class="o">=</span> <span class="n">new</span> <span class="n">PathPrinter</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">:</span> <span class="n">traverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">pathToString</span><span class="p">(</span> <span class="n">path</span><span class="p">,</span> <span class="n">pathPrinter</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>输出结果:</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">REL1</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">REL2</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">REL3</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>在这种情况下我们使用一个自定义类来格式化路径输出。下面是它的具体实现：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">static</span> <span class="k">class</span> <span class="nc">PathPrinter</span> <span class="n">implements</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">PathDescriptor</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">final</span> <span class="n">String</span> <span class="n">nodePropertyKey</span><span class="p">;</span>

    <span class="n">public</span> <span class="n">PathPrinter</span><span class="p">(</span> <span class="n">String</span> <span class="n">nodePropertyKey</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">nodePropertyKey</span> <span class="o">=</span> <span class="n">nodePropertyKey</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">String</span> <span class="n">nodeRepresentation</span><span class="p">(</span> <span class="n">Path</span> <span class="n">path</span><span class="p">,</span> <span class="n">Node</span> <span class="n">node</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s2">"("</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="n">nodePropertyKey</span><span class="p">,</span> <span class="s2">""</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">")"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">String</span> <span class="n">relationshipRepresentation</span><span class="p">(</span> <span class="n">Path</span> <span class="n">path</span><span class="p">,</span> <span class="n">Node</span> <span class="n">from</span><span class="p">,</span>
            <span class="n">Relationship</span> <span class="n">relationship</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">String</span> <span class="n">prefix</span> <span class="o">=</span> <span class="s2">"--"</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="s2">"--"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">from</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span> <span class="n">relationship</span><span class="o">.</span><span class="n">getEndNode</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">"&lt;--"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s2">"--&gt;"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">"["</span> <span class="o">+</span> <span class="n">relationship</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="s2">"]"</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>为了了解更多关于 Path 的有选择的输出的细节，请参考：<a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/kernel/Traversal.html">Traversal类</a> 。</p> 
   <p><strong>注意</strong></p> 
   <blockquote> 
    <div>
     下面的范例使用了一个已经废弃的遍历API。它与新的遍历查询API共享底层实现，所以它们的性能是一样的。比较起来它提供的功能非常有限。
    </div>
   </blockquote> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="api"> 
 <h2>4.5.2. 老的遍历查询 API<a class="headerlink" href="#api" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>这是我们想遍历查询的第一个图数据库：</p> 
   <p>图 4.3. 黑客帝国节点空间预览</p> 
   <div class="figure"> 
    <img alt="../_images/image4.4.png" src="../_images/image4.4.png"> 
   </div> 
   <p>提示</p> 
   <blockquote> 
    <div>
     范例源代码下载地址： 
     <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/Matrix.java">Matrix.java</a>
    </div>
   </blockquote> 
   <p>朋友以及朋友的朋友.</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">Traverser</span> <span class="n">getFriends</span><span class="p">(</span> <span class="n">final</span> <span class="n">Node</span> <span class="n">person</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">person</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">Order</span><span class="o">.</span><span class="n">BREADTH_FIRST</span><span class="p">,</span>
            <span class="n">StopEvaluator</span><span class="o">.</span><span class="n">END_OF_GRAPH</span><span class="p">,</span>
            <span class="n">ReturnableEvaluator</span><span class="o">.</span><span class="n">ALL_BUT_START_NODE</span><span class="p">,</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span><span class="p">,</span>
            <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>让我们执行一次真实的遍历查询并打印结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="nb">int</span> <span class="n">numberOfFriends</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="n">neoNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"'s friends:</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="n">Traverser</span> <span class="n">friendsTraverser</span> <span class="o">=</span> <span class="n">getFriends</span><span class="p">(</span> <span class="n">neoNode</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Node</span> <span class="n">friendNode</span> <span class="p">:</span> <span class="n">friendsTraverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="s2">"At depth "</span> <span class="o">+</span>
                <span class="n">friendsTraverser</span><span class="o">.</span><span class="n">currentPosition</span><span class="p">()</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span> <span class="o">+</span>
                <span class="s2">" =&gt; "</span> <span class="o">+</span>
                <span class="n">friendNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="n">numberOfFriends</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">+=</span> <span class="s2">"Number of friends found: "</span> <span class="o">+</span> <span class="n">numberOfFriends</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>下面是输出结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>Thomas Anderson 的朋友们:
At depth 1 =&gt; Trinity
At depth 1 =&gt; Morpheus
At depth 2 =&gt; Cypher
At depth 3 =&gt; Agent Smith
一共找到朋友数量: 4
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>是谁编写了黑客帝国呢?</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>private static Traverser findHackers( final Node startNode ) {
    return startNode.traverse( Order.BREADTH_FIRST,
            StopEvaluator.END_OF_GRAPH, new ReturnableEvaluator()
    {
        @Override
        public boolean isReturnableNode(
                final TraversalPosition currentPos )
        {
            return !currentPos.isStartNode()
            &amp;&amp; currentPos.lastRelationshipTraversed()
            .isType( RelTypes.CODED_BY );
        }
    }, RelTypes.CODED_BY, Direction.OUTGOING, RelTypes.KNOWS,
    Direction.OUTGOING );
}
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>输出结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="s2">"Hackers:</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">numberOfHackers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Traverser</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">findHackers</span><span class="p">(</span> <span class="n">getNeoNode</span><span class="p">()</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Node</span> <span class="n">hackerNode</span> <span class="p">:</span> <span class="n">traverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="s2">"At depth "</span> <span class="o">+</span>
                <span class="n">traverser</span><span class="o">.</span><span class="n">currentPosition</span><span class="p">()</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span> <span class="o">+</span>
                <span class="s2">" =&gt; "</span> <span class="o">+</span>
                <span class="n">hackerNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="n">numberOfHackers</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">+=</span> <span class="s2">"Number of hackers found: "</span> <span class="o">+</span> <span class="n">numberOfHackers</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>现在我们知道是谁编写了黑客帝国:</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>Hackers:
At depth 4 =&gt; The Architect
找到hackers的数量: 1
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>4.5.3. 在遍历查询中的唯一路径<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>这个范例演示了节点唯一性的使用。下面是一个想象的有多个负责人的领域图，这些负责人有它们增加的宠物，而这些宠物又生产了它的后代。</p> 
   <p><cite>图 4.4. 后代范例图</cite></p> 
   <div class="figure"> 
    <img alt="../_images/image4.5.png" src="../_images/image4.5.png"> 
   </div> 
   <p>为了返回 Pet0 的所有后代，要求与 Pet0 必须有 owns 和 Principal1 关系（实际上只有 Pet1 和 Pet3 ），遍历查询的 <cite>Uniqueness</cite> 应该设置成 <strong>NODE_PATH</strong> 来代替默认的 <strong>NODE_GLOBAL</strong> 以至于节点可以被遍历不止一次，而且那些有不同节点但能有一些相同的路径（比如开始节点和结束节点）也能被返回。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">final</span> <span class="n">Node</span> <span class="n">target</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="s2">"Principal1"</span> <span class="p">);</span>
<span class="n">TraversalDescription</span> <span class="n">td</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
        <span class="o">.</span><span class="n">uniqueness</span><span class="p">(</span> <span class="n">Uniqueness</span><span class="o">.</span><span class="n">NODE_PATH</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">new</span> <span class="n">Evaluator</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">Evaluation</span> <span class="n">evaluate</span><span class="p">(</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">endNode</span><span class="p">()</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span> <span class="n">target</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">Evaluation</span><span class="o">.</span><span class="n">INCLUDE_AND_PRUNE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">Evaluation</span><span class="o">.</span><span class="n">EXCLUDE_AND_CONTINUE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">);</span>

<span class="n">Traverser</span> <span class="n">results</span> <span class="o">=</span> <span class="n">td</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">start</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>这将返回下面的路径:</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">descendant</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">owns</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">descendant</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">owns</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>在 <cite>path.toString()</cite> 的默认实现中，(1)–[knows,2]–&gt;(4) 表示一个ID=1的节点通过一个ID=2，关系类型为 knows 的关系连接到了一个ID=4的节点上。</p> 
   <p>让我们从一个旧的中创建一个新的 <cite>TraversalDescription</cite> ，并且设置 <cite>uniqueness</cite> 为 <strong>NODE_GLOBAL</strong> 来查看它们之间的区别。</p> 
   <p>提示</p> 
   <blockquote> 
    <div>
     <cite>TraversalDescription</cite> 对象是不变的，因此我们必须使用一个新的实例来返回新的 
     <cite>uniqueness</cite> 设置。
    </div>
   </blockquote> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">TraversalDescription</span> <span class="n">nodeGlobalTd</span> <span class="o">=</span> <span class="n">td</span><span class="o">.</span><span class="n">uniqueness</span><span class="p">(</span> <span class="n">Uniqueness</span><span class="o">.</span><span class="n">NODE_GLOBAL</span> <span class="p">);</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">nodeGlobalTd</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">start</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>现在只有一条路径返回:</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">descendant</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">owns</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>4.5.4. 社交网络<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>注意: 下面的范例使用了处于实验阶段的遍历查询API。</p> 
   <p>社交网络（在互联网上也被称为社交图）是天然的用图来表示的模型。下面的范例演示了一个非常简单的社交模型，它连接了朋友并关注了好友动态。</p> 
   <p>提示</p> 
   <blockquote> 
    <div>
     范例源代码下载地址： 
     <a class="reference external" href="https://github.com/neo4j/community/tree/1.8/embedded-examples/src/main/java/org/neo4j/examples/socnet">socnet</a>
    </div>
   </blockquote> 
   <p>简单的社交模型</p> 
   <p>图 4.5. 社交网络数据模型</p> 
   <div class="figure"> 
    <img alt="../_images/image4.6.png" src="../_images/image4.6.png"> 
   </div> 
   <p>一个社交网络的数据模型是简漂亮的：有名称的 <cite>Persons</cite> 和有时间戳文本的 <cite>StatusUpdates</cite> 。这些实体然后通过特殊的关系连接在一起。</p> 
   <ul> 
    <li><p class="first">Person</p> 
     <blockquote> 
      <div>
       <ul class="simple"> 
        <li>friend: 连接两个不同 Person 实例的关系 (不能连接自己)</li> 
        <li>status: 连接到最近的 StatusUpdate</li> 
       </ul> 
      </div>
     </blockquote> </li> 
    <li><p class="first">StatusUpdate</p> 
     <blockquote> 
      <div>
       <ul class="simple"> 
        <li>next: 指向在主线上的下一个 StatusUpdate ，是在当前这个状态更新之前发生的</li> 
       </ul> 
      </div>
     </blockquote> </li> 
   </ul> 
   <p>状态图实例</p> 
   <p>一个 <strong>Person</strong> 的 <strong>StatusUpdate</strong> 列表 是一个链表。表头（最近动态）可以通过下一个 <strong>status</strong> 找到。每一个随后的 <strong>StatusUpdate</strong> 都通过关系 next 相连。</p> 
   <p>这是一个 Andreas Kollegger 微博记录图早上走路上班的范例：</p> 
   <div class="figure"> 
    <img alt="../_images/image4.7.png" src="../_images/image4.7.png"> 
   </div> 
   <p>为了读取状态更新情况，我们可以创建一个遍历查询，比如：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">TraversalDescription</span> <span class="n">traversal</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span><span class="o">.</span>
    <span class="n">depthFirst</span><span class="p">()</span><span class="o">.</span>
    <span class="n">relationships</span><span class="p">(</span> <span class="n">NEXT</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>这给了我们一个遍历查询，它将从一个 <strong>StatusUpdate</strong> 开始，并一直跟随状态的主线直到它们运行结束。遍历查询是懒加载模式所以当我们处理成千上万状态的时候性能一样很好—除非我们真实使用它们，否在它们不会被加载。</p> 
   <p><strong>活动流</strong></p> 
   <blockquote> 
    <div>
     <p>一旦我们有了朋友，而且它们有了状态消息，我们可能想读取我们的朋友的消息动态，按时间倒序排列—最新的动态在前面。为了实现这个，我们可以通过下面几个步骤：</p> 
     <blockquote> 
      <div>
       <ol class="arabic simple"> 
        <li>抓取所有的好友动态放入一个列表—最新的排前面。</li> 
        <li>对列表进行排序。</li> 
        <li>返回列表中的第一个记录。</li> 
        <li>如果第一个迭代器为空，则把它从列表移除。否则，在这个迭代器中获取下一个记录。</li> 
        <li>跳转到步骤2直到在列表中没有任何记录。</li> 
       </ol> 
      </div>
     </blockquote> 
    </div>
   </blockquote> 
   <p>这个队列看起来像 <a class="reference external" href="http://www.slideshare.net/systay/pattern-activity-stream">这样</a> 。</p> 
   <p>代码实现像这样：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>PositionedIterator&lt;StatusUpdate&gt; first = statuses.get(0);
StatusUpdate returnVal = first.current();

if ( !first.hasNext() )
{
    statuses.remove( 0 );
}
else
{
    first.next();
    sort();
}

return returnVal;
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
  </div>
 </blockquote> 
</div>
<h2>4.5.1. 黑客帝国<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>对于上面的黑客帝国范例的遍历查询，这次使用新的遍历API：</p> 
  <p>提示</p> 
  <blockquote> 
   <div>
    范例源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/NewMatrix.java">NewMatrix.java</a>
   </div>
  </blockquote> 
  <p>朋友以及朋友的朋友.</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">Traverser</span> <span class="n">getFriends</span><span class="p">(</span> <span class="n">final</span> <span class="n">Node</span> <span class="n">person</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">TraversalDescription</span> <span class="n">td</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
        <span class="o">.</span><span class="n">breadthFirst</span><span class="p">()</span>
        <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">excludeStartPosition</span><span class="p">()</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">td</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">person</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>让我们只想一次真实的遍历查询并打印结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="nb">int</span> <span class="n">numberOfFriends</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="n">neoNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"'s friends:</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="n">Traverser</span> <span class="n">friendsTraverser</span> <span class="o">=</span> <span class="n">getFriends</span><span class="p">(</span> <span class="n">neoNode</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">friendPath</span> <span class="p">:</span> <span class="n">friendsTraverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="s2">"At depth "</span> <span class="o">+</span> <span class="n">friendPath</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="s2">" =&gt; "</span>
              <span class="o">+</span> <span class="n">friendPath</span><span class="o">.</span><span class="n">endNode</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="n">numberOfFriends</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">+=</span> <span class="s2">"Number of friends found: "</span> <span class="o">+</span> <span class="n">numberOfFriends</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>输出结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>Thomas Anderson's friends:
At depth 1 =&gt; Trinity
At depth 1 =&gt; Morpheus
At depth 2 =&gt; Cypher
At depth 3 =&gt; Agent Smith
找到朋友的数量: 4
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>谁编写了黑客帝国？</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7
8
9</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">Traverser</span> <span class="n">findHackers</span><span class="p">(</span> <span class="n">final</span> <span class="n">Node</span> <span class="n">startNode</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">TraversalDescription</span> <span class="n">td</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
            <span class="o">.</span><span class="n">breadthFirst</span><span class="p">()</span>
            <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">CODED_BY</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">)</span>
            <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">)</span>
            <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span>
                    <span class="n">Evaluators</span><span class="o">.</span><span class="n">includeWhereLastRelationshipTypeIs</span><span class="p">(</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">CODED_BY</span> <span class="p">)</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">td</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">startNode</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>打印输出结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="s2">"Hackers:</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">numberOfHackers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Traverser</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">findHackers</span><span class="p">(</span> <span class="n">getNeoNode</span><span class="p">()</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">hackerPath</span> <span class="p">:</span> <span class="n">traverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="s2">"At depth "</span> <span class="o">+</span> <span class="n">hackerPath</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">+</span> <span class="s2">" =&gt; "</span>
              <span class="o">+</span> <span class="n">hackerPath</span><span class="o">.</span><span class="n">endNode</span><span class="p">()</span>
                      <span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="n">numberOfHackers</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">+=</span> <span class="s2">"Number of hackers found: "</span> <span class="o">+</span> <span class="n">numberOfHackers</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>现在我们知道是谁编写了黑客帝国:</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>Hackers:
At depth 4 =&gt; The Architect
找到hackers的数量: 1
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>游走一个有序路径</p> 
  <p>这个范例展示了如何通过一个路径上下文控制一条路径的表现。</p> 
  <p>提示</p> 
  <blockquote> 
   <div>
    范例源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/orderedpath/OrderedPath.java">OrderedPath.java</a>
   </div>
  </blockquote> 
  <p>创建一个图数据库.</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7
8</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Node</span> <span class="n">A</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">B</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">C</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">D</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">A</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">B</span><span class="p">,</span> <span class="n">REL1</span> <span class="p">);</span>
<span class="n">B</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">C</span><span class="p">,</span> <span class="n">REL2</span> <span class="p">);</span>
<span class="n">C</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">D</span><span class="p">,</span> <span class="n">REL3</span> <span class="p">);</span>
<span class="n">A</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span> <span class="n">C</span><span class="p">,</span> <span class="n">REL2</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <div class="figure"> 
   <img alt="../_images/image4.3.png" src="../_images/image4.3.png"> 
  </div> 
  <p>现在，关系 ( REL1 → REL2 → REL3 ) 的顺序保存在 一个 <code class="docutils literal"><span class="pre">ArrayList</span></code> 对象中。当遍历的时候，Evaluator 能针对它进行检查，确保只有拥有预定义关系顺序的路径才会被包括并返回：</p> 
  <p>定义如何游走这个路径.</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">final</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">RelationshipType</span><span class="o">&gt;</span> <span class="n">orderedPathContext</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">RelationshipType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">orderedPathContext</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">REL1</span> <span class="p">);</span>
<span class="n">orderedPathContext</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">withName</span><span class="p">(</span> <span class="s2">"REL2"</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">orderedPathContext</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">withName</span><span class="p">(</span> <span class="s2">"REL3"</span> <span class="p">)</span> <span class="p">);</span>
<span class="n">TraversalDescription</span> <span class="n">td</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
    <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">new</span> <span class="n">Evaluator</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">@Override</span>
        <span class="n">public</span> <span class="n">Evaluation</span> <span class="n">evaluate</span><span class="p">(</span> <span class="n">final</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">Evaluation</span><span class="o">.</span><span class="n">EXCLUDE_AND_CONTINUE</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">RelationshipType</span> <span class="n">expectedType</span> <span class="o">=</span> <span class="n">orderedPathContext</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
            <span class="n">boolean</span> <span class="n">isExpectedType</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">lastRelationship</span><span class="p">()</span>
                    <span class="o">.</span><span class="n">isType</span><span class="p">(</span> <span class="n">expectedType</span> <span class="p">);</span>
            <span class="n">boolean</span> <span class="n">included</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="n">orderedPathContext</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
                               <span class="o">&amp;&amp;</span> <span class="n">isExpectedType</span><span class="p">;</span>
            <span class="n">boolean</span> <span class="n">continued</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">orderedPathContext</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
                                <span class="o">&amp;&amp;</span> <span class="n">isExpectedType</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">Evaluation</span><span class="o">.</span><span class="n">of</span><span class="p">(</span> <span class="n">included</span><span class="p">,</span> <span class="n">continued</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>执行一次遍历查询并返回结果.</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Traverser</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">td</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">A</span> <span class="p">);</span>
<span class="n">PathPrinter</span> <span class="n">pathPrinter</span> <span class="o">=</span> <span class="n">new</span> <span class="n">PathPrinter</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">:</span> <span class="n">traverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">pathToString</span><span class="p">(</span> <span class="n">path</span><span class="p">,</span> <span class="n">pathPrinter</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>输出结果:</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">REL1</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">REL2</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">REL3</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在这种情况下我们使用一个自定义类来格式化路径输出。下面是它的具体实现：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">static</span> <span class="k">class</span> <span class="nc">PathPrinter</span> <span class="n">implements</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">PathDescriptor</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">private</span> <span class="n">final</span> <span class="n">String</span> <span class="n">nodePropertyKey</span><span class="p">;</span>

    <span class="n">public</span> <span class="n">PathPrinter</span><span class="p">(</span> <span class="n">String</span> <span class="n">nodePropertyKey</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">this</span><span class="o">.</span><span class="n">nodePropertyKey</span> <span class="o">=</span> <span class="n">nodePropertyKey</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">String</span> <span class="n">nodeRepresentation</span><span class="p">(</span> <span class="n">Path</span> <span class="n">path</span><span class="p">,</span> <span class="n">Node</span> <span class="n">node</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s2">"("</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="n">nodePropertyKey</span><span class="p">,</span> <span class="s2">""</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">")"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">String</span> <span class="n">relationshipRepresentation</span><span class="p">(</span> <span class="n">Path</span> <span class="n">path</span><span class="p">,</span> <span class="n">Node</span> <span class="n">from</span><span class="p">,</span>
            <span class="n">Relationship</span> <span class="n">relationship</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">String</span> <span class="n">prefix</span> <span class="o">=</span> <span class="s2">"--"</span><span class="p">,</span> <span class="n">suffix</span> <span class="o">=</span> <span class="s2">"--"</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">from</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span> <span class="n">relationship</span><span class="o">.</span><span class="n">getEndNode</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s2">"&lt;--"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="s2">"--&gt;"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="s2">"["</span> <span class="o">+</span> <span class="n">relationship</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">()</span> <span class="o">+</span> <span class="s2">"]"</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>为了了解更多关于 Path 的有选择的输出的细节，请参考：<a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/kernel/Traversal.html">Traversal类</a> 。</p> 
  <p><strong>注意</strong></p> 
  <blockquote> 
   <div>
    下面的范例使用了一个已经废弃的遍历API。它与新的遍历查询API共享底层实现，所以它们的性能是一样的。比较起来它提供的功能非常有限。
   </div>
  </blockquote> 
 </div>
</blockquote>
<h2>4.5.2. 老的遍历查询 API<a class="headerlink" href="#api" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>这是我们想遍历查询的第一个图数据库：</p> 
  <p>图 4.3. 黑客帝国节点空间预览</p> 
  <div class="figure"> 
   <img alt="../_images/image4.4.png" src="../_images/image4.4.png"> 
  </div> 
  <p>提示</p> 
  <blockquote> 
   <div>
    范例源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/Matrix.java">Matrix.java</a>
   </div>
  </blockquote> 
  <p>朋友以及朋友的朋友.</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">private</span> <span class="n">static</span> <span class="n">Traverser</span> <span class="n">getFriends</span><span class="p">(</span> <span class="n">final</span> <span class="n">Node</span> <span class="n">person</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">person</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">Order</span><span class="o">.</span><span class="n">BREADTH_FIRST</span><span class="p">,</span>
            <span class="n">StopEvaluator</span><span class="o">.</span><span class="n">END_OF_GRAPH</span><span class="p">,</span>
            <span class="n">ReturnableEvaluator</span><span class="o">.</span><span class="n">ALL_BUT_START_NODE</span><span class="p">,</span> <span class="n">RelTypes</span><span class="o">.</span><span class="n">KNOWS</span><span class="p">,</span>
            <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>让我们执行一次真实的遍历查询并打印结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="nb">int</span> <span class="n">numberOfFriends</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="n">neoNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"'s friends:</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="n">Traverser</span> <span class="n">friendsTraverser</span> <span class="o">=</span> <span class="n">getFriends</span><span class="p">(</span> <span class="n">neoNode</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Node</span> <span class="n">friendNode</span> <span class="p">:</span> <span class="n">friendsTraverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="s2">"At depth "</span> <span class="o">+</span>
                <span class="n">friendsTraverser</span><span class="o">.</span><span class="n">currentPosition</span><span class="p">()</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span> <span class="o">+</span>
                <span class="s2">" =&gt; "</span> <span class="o">+</span>
                <span class="n">friendNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="n">numberOfFriends</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">+=</span> <span class="s2">"Number of friends found: "</span> <span class="o">+</span> <span class="n">numberOfFriends</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>下面是输出结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>Thomas Anderson 的朋友们:
At depth 1 =&gt; Trinity
At depth 1 =&gt; Morpheus
At depth 2 =&gt; Cypher
At depth 3 =&gt; Agent Smith
一共找到朋友数量: 4
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>是谁编写了黑客帝国呢?</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>private static Traverser findHackers( final Node startNode ) {
    return startNode.traverse( Order.BREADTH_FIRST,
            StopEvaluator.END_OF_GRAPH, new ReturnableEvaluator()
    {
        @Override
        public boolean isReturnableNode(
                final TraversalPosition currentPos )
        {
            return !currentPos.isStartNode()
            &amp;&amp; currentPos.lastRelationshipTraversed()
            .isType( RelTypes.CODED_BY );
        }
    }, RelTypes.CODED_BY, Direction.OUTGOING, RelTypes.KNOWS,
    Direction.OUTGOING );
}
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>输出结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">String</span> <span class="n">output</span> <span class="o">=</span> <span class="s2">"Hackers:</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">numberOfHackers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Traverser</span> <span class="n">traverser</span> <span class="o">=</span> <span class="n">findHackers</span><span class="p">(</span> <span class="n">getNeoNode</span><span class="p">()</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Node</span> <span class="n">hackerNode</span> <span class="p">:</span> <span class="n">traverser</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="s2">"At depth "</span> <span class="o">+</span>
                <span class="n">traverser</span><span class="o">.</span><span class="n">currentPosition</span><span class="p">()</span><span class="o">.</span><span class="n">depth</span><span class="p">()</span> <span class="o">+</span>
                <span class="s2">" =&gt; "</span> <span class="o">+</span>
                <span class="n">hackerNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
    <span class="n">numberOfHackers</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">output</span> <span class="o">+=</span> <span class="s2">"Number of hackers found: "</span> <span class="o">+</span> <span class="n">numberOfHackers</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>现在我们知道是谁编写了黑客帝国:</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>Hackers:
At depth 4 =&gt; The Architect
找到hackers的数量: 1
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote>
<h2>4.5.3. 在遍历查询中的唯一路径<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>这个范例演示了节点唯一性的使用。下面是一个想象的有多个负责人的领域图，这些负责人有它们增加的宠物，而这些宠物又生产了它的后代。</p> 
  <p><cite>图 4.4. 后代范例图</cite></p> 
  <div class="figure"> 
   <img alt="../_images/image4.5.png" src="../_images/image4.5.png"> 
  </div> 
  <p>为了返回 Pet0 的所有后代，要求与 Pet0 必须有 owns 和 Principal1 关系（实际上只有 Pet1 和 Pet3 ），遍历查询的 <cite>Uniqueness</cite> 应该设置成 <strong>NODE_PATH</strong> 来代替默认的 <strong>NODE_GLOBAL</strong> 以至于节点可以被遍历不止一次，而且那些有不同节点但能有一些相同的路径（比如开始节点和结束节点）也能被返回。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">final</span> <span class="n">Node</span> <span class="n">target</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="s2">"Principal1"</span> <span class="p">);</span>
<span class="n">TraversalDescription</span> <span class="n">td</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
        <span class="o">.</span><span class="n">uniqueness</span><span class="p">(</span> <span class="n">Uniqueness</span><span class="o">.</span><span class="n">NODE_PATH</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">new</span> <span class="n">Evaluator</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">Evaluation</span> <span class="n">evaluate</span><span class="p">(</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">path</span><span class="o">.</span><span class="n">endNode</span><span class="p">()</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span> <span class="n">target</span> <span class="p">)</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">Evaluation</span><span class="o">.</span><span class="n">INCLUDE_AND_PRUNE</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">Evaluation</span><span class="o">.</span><span class="n">EXCLUDE_AND_CONTINUE</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">);</span>

<span class="n">Traverser</span> <span class="n">results</span> <span class="o">=</span> <span class="n">td</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">start</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>这将返回下面的路径:</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">descendant</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">owns</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">descendant</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">owns</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在 <cite>path.toString()</cite> 的默认实现中，(1)–[knows,2]–&gt;(4) 表示一个ID=1的节点通过一个ID=2，关系类型为 knows 的关系连接到了一个ID=4的节点上。</p> 
  <p>让我们从一个旧的中创建一个新的 <cite>TraversalDescription</cite> ，并且设置 <cite>uniqueness</cite> 为 <strong>NODE_GLOBAL</strong> 来查看它们之间的区别。</p> 
  <p>提示</p> 
  <blockquote> 
   <div>
    <cite>TraversalDescription</cite> 对象是不变的，因此我们必须使用一个新的实例来返回新的 
    <cite>uniqueness</cite> 设置。
   </div>
  </blockquote> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">TraversalDescription</span> <span class="n">nodeGlobalTd</span> <span class="o">=</span> <span class="n">td</span><span class="o">.</span><span class="n">uniqueness</span><span class="p">(</span> <span class="n">Uniqueness</span><span class="o">.</span><span class="n">NODE_GLOBAL</span> <span class="p">);</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">nodeGlobalTd</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">start</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>现在只有一条路径返回:</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">descendant</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">owns</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote>
<h2>4.5.4. 社交网络<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>注意: 下面的范例使用了处于实验阶段的遍历查询API。</p> 
  <p>社交网络（在互联网上也被称为社交图）是天然的用图来表示的模型。下面的范例演示了一个非常简单的社交模型，它连接了朋友并关注了好友动态。</p> 
  <p>提示</p> 
  <blockquote> 
   <div>
    范例源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/tree/1.8/embedded-examples/src/main/java/org/neo4j/examples/socnet">socnet</a>
   </div>
  </blockquote> 
  <p>简单的社交模型</p> 
  <p>图 4.5. 社交网络数据模型</p> 
  <div class="figure"> 
   <img alt="../_images/image4.6.png" src="../_images/image4.6.png"> 
  </div> 
  <p>一个社交网络的数据模型是简漂亮的：有名称的 <cite>Persons</cite> 和有时间戳文本的 <cite>StatusUpdates</cite> 。这些实体然后通过特殊的关系连接在一起。</p> 
  <ul> 
   <li><p class="first">Person</p> 
    <blockquote> 
     <div>
      <ul class="simple"> 
       <li>friend: 连接两个不同 Person 实例的关系 (不能连接自己)</li> 
       <li>status: 连接到最近的 StatusUpdate</li> 
      </ul> 
     </div>
    </blockquote> </li> 
   <li><p class="first">StatusUpdate</p> 
    <blockquote> 
     <div>
      <ul class="simple"> 
       <li>next: 指向在主线上的下一个 StatusUpdate ，是在当前这个状态更新之前发生的</li> 
      </ul> 
     </div>
    </blockquote> </li> 
  </ul> 
  <p>状态图实例</p> 
  <p>一个 <strong>Person</strong> 的 <strong>StatusUpdate</strong> 列表 是一个链表。表头（最近动态）可以通过下一个 <strong>status</strong> 找到。每一个随后的 <strong>StatusUpdate</strong> 都通过关系 next 相连。</p> 
  <p>这是一个 Andreas Kollegger 微博记录图早上走路上班的范例：</p> 
  <div class="figure"> 
   <img alt="../_images/image4.7.png" src="../_images/image4.7.png"> 
  </div> 
  <p>为了读取状态更新情况，我们可以创建一个遍历查询，比如：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">TraversalDescription</span> <span class="n">traversal</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span><span class="o">.</span>
    <span class="n">depthFirst</span><span class="p">()</span><span class="o">.</span>
    <span class="n">relationships</span><span class="p">(</span> <span class="n">NEXT</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>这给了我们一个遍历查询，它将从一个 <strong>StatusUpdate</strong> 开始，并一直跟随状态的主线直到它们运行结束。遍历查询是懒加载模式所以当我们处理成千上万状态的时候性能一样很好—除非我们真实使用它们，否在它们不会被加载。</p> 
  <p><strong>活动流</strong></p> 
  <blockquote> 
   <div>
    <p>一旦我们有了朋友，而且它们有了状态消息，我们可能想读取我们的朋友的消息动态，按时间倒序排列—最新的动态在前面。为了实现这个，我们可以通过下面几个步骤：</p> 
    <blockquote> 
     <div>
      <ol class="arabic simple"> 
       <li>抓取所有的好友动态放入一个列表—最新的排前面。</li> 
       <li>对列表进行排序。</li> 
       <li>返回列表中的第一个记录。</li> 
       <li>如果第一个迭代器为空，则把它从列表移除。否则，在这个迭代器中获取下一个记录。</li> 
       <li>跳转到步骤2直到在列表中没有任何记录。</li> 
      </ol> 
     </div>
    </blockquote> 
   </div>
  </blockquote> 
  <p>这个队列看起来像 <a class="reference external" href="http://www.slideshare.net/systay/pattern-activity-stream">这样</a> 。</p> 
  <p>代码实现像这样：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>PositionedIterator&lt;StatusUpdate&gt; first = statuses.get(0);
StatusUpdate returnVal = first.current();

if ( !first.hasNext() )
{
    statuses.remove( 0 );
}
else
{
    first.next();
    sort();
}

return returnVal;
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote><span id="id1"></span>
<h1>4.6. 领域实体<a class="headerlink" href="#chapter4-6-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>这个地方演示了当使用Neo4j时控制领域实体的一个方法。使用的原则是将实体封装到节点上（这个方法也可以用在关系上）。</p> 
  <p><strong>提示</strong></p> 
  <blockquote> 
   <div>
    范例源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/socnet/Person.java">Person.java</a>
   </div>
  </blockquote> 
  <p>马上，保存节点并且让它在包里可以被访问：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">private</span> <span class="n">final</span> <span class="n">Node</span> <span class="n">underlyingNode</span><span class="p">;</span>
<span class="n">Person</span><span class="p">(</span> <span class="n">Node</span> <span class="n">personNode</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">underlyingNode</span> <span class="o">=</span> <span class="n">personNode</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">protected</span> <span class="n">Node</span> <span class="n">getUnderlyingNode</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">underlyingNode</span><span class="p">;</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>分配属性给节点：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">public</span> <span class="n">String</span> <span class="n">getName</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">String</span><span class="p">)</span><span class="n">underlyingNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="n">NAME</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>确保重载这些方法：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="nd">@Override</span>
<span class="n">public</span> <span class="nb">int</span> <span class="n">hashCode</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">underlyingNode</span><span class="o">.</span><span class="n">hashCode</span><span class="p">();</span>
<span class="p">}</span>

<span class="nd">@Override</span>
<span class="n">public</span> <span class="n">boolean</span> <span class="n">equals</span><span class="p">(</span> <span class="n">Object</span> <span class="n">o</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">o</span> <span class="n">instanceof</span> <span class="n">Person</span> <span class="o">&amp;&amp;</span>
            <span class="n">underlyingNode</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span> <span class="p">(</span> <span class="p">(</span><span class="n">Person</span><span class="p">)</span><span class="n">o</span> <span class="p">)</span><span class="o">.</span><span class="n">getUnderlyingNode</span><span class="p">()</span> <span class="p">);</span>
<span class="p">}</span>

<span class="nd">@Override</span>
<span class="n">public</span> <span class="n">String</span> <span class="n">toString</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s2">"Person["</span> <span class="o">+</span> <span class="n">getName</span><span class="p">()</span> <span class="o">+</span> <span class="s2">"]"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote><span id="id1"></span>
<h1>4.7. 图算法范例<a class="headerlink" href="#chapter4-7-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p><strong>提示</strong></p> 
  <blockquote> 
   <div>
    范例源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/test/java/org/neo4j/examples/PathFindingExamplesTest.java">PathFindingExamplesTest.java</a>
   </div>
  </blockquote> 
  <p>计算正连个节点之间的最短路径（最少数目的关系）：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Node</span> <span class="n">startNode</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">middleNode1</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">middleNode2</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">middleNode3</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">Node</span> <span class="n">endNode</span> <span class="o">=</span> <span class="n">graphDb</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
<span class="n">createRelationshipsBetween</span><span class="p">(</span> <span class="n">startNode</span><span class="p">,</span> <span class="n">middleNode1</span><span class="p">,</span> <span class="n">endNode</span> <span class="p">);</span>
<span class="n">createRelationshipsBetween</span><span class="p">(</span> <span class="n">startNode</span><span class="p">,</span> <span class="n">middleNode2</span><span class="p">,</span> <span class="n">middleNode3</span><span class="p">,</span> <span class="n">endNode</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Will</span> <span class="n">find</span> <span class="n">the</span> <span class="n">shortest</span> <span class="n">path</span> <span class="n">between</span> <span class="n">startNode</span> <span class="ow">and</span> <span class="n">endNode</span> <span class="n">via</span>
<span class="o">//</span> <span class="s2">"MY_TYPE"</span> <span class="n">relationships</span> <span class="p">(</span><span class="ow">in</span> <span class="n">OUTGOING</span> <span class="n">direction</span><span class="p">),</span> <span class="n">like</span> <span class="n">f</span><span class="o">.</span><span class="n">ex</span><span class="p">:</span>
<span class="o">//</span>
<span class="o">//</span> <span class="p">(</span><span class="n">startNode</span><span class="p">)</span><span class="o">--&gt;</span><span class="p">(</span><span class="n">middleNode1</span><span class="p">)</span><span class="o">--&gt;</span><span class="p">(</span><span class="n">endNode</span><span class="p">)</span>
<span class="o">//</span>
<span class="n">PathFinder</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="n">finder</span> <span class="o">=</span> <span class="n">GraphAlgoFactory</span><span class="o">.</span><span class="n">shortestPath</span><span class="p">(</span>
    <span class="n">Traversal</span><span class="o">.</span><span class="n">expanderForTypes</span><span class="p">(</span> <span class="n">ExampleTypes</span><span class="o">.</span><span class="n">MY_TYPE</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">OUTGOING</span> <span class="p">),</span> <span class="mi">15</span> <span class="p">);</span>
<span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">findAllPaths</span><span class="p">(</span> <span class="n">startNode</span><span class="p">,</span> <span class="n">endNode</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>使用 <a class="reference external" href="http://zh.wikipedia.org/wiki/Dijkstra">迪科斯彻（Dijkstra）</a> 算法解决有向图中任意两个顶点之间的最短路径问题。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">PathFinder</span><span class="o">&lt;</span><span class="n">WeightedPath</span><span class="o">&gt;</span> <span class="n">finder</span> <span class="o">=</span> <span class="n">GraphAlgoFactory</span><span class="o">.</span><span class="n">dijkstra</span><span class="p">(</span>
<span class="n">Traversal</span><span class="o">.</span><span class="n">expanderForTypes</span><span class="p">(</span> <span class="n">ExampleTypes</span><span class="o">.</span><span class="n">MY_TYPE</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">BOTH</span> <span class="p">),</span> <span class="s2">"cost"</span> <span class="p">);</span>

<span class="n">WeightedPath</span> <span class="n">path</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="n">findSinglePath</span><span class="p">(</span> <span class="n">nodeA</span><span class="p">,</span> <span class="n">nodeB</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">Get</span> <span class="n">the</span> <span class="n">weight</span> <span class="k">for</span> <span class="n">the</span> <span class="n">found</span> <span class="n">path</span>
<span class="n">path</span><span class="o">.</span><span class="n">weight</span><span class="p">();</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>使用 <strong>A*</strong> 算法是解决静态路网中求解最短路最有效的方法。</p> 
  <p>这儿是我们的范例图：</p> 
  <div class="figure"> 
   <img alt="../_images/image4.8.png" src="../_images/image4.8.png"> 
  </div> 
 </div>
</blockquote><span id="id1"></span>
<h1>4.8. 读取一个管理配置属性<a class="headerlink" href="#chapter4-8-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p><a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/kernel/EmbeddedGraphDatabase.html">EmbeddedGraphDatabase</a> 类包括了一个 <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/kernel/EmbeddedGraphDatabase.html#getManagementBean%28java.lang.Class%29">方便的方法</a> 来获取Neo4j管理用的beans。</p> 
  <p>一般JMX服务也能使用，但比起你自己编码不如使用这概述的方法。</p> 
  <p><strong>提示</strong></p> 
  <blockquote> 
   <div>
    范例源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/test/java/org/neo4j/examples/JmxTest.java">JmxTest.java</a>
   </div>
  </blockquote> 
  <p>这个范例演示了如何得到一个图数据库的开始时间：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>private static Date getStartTimeFromManagementBean( GraphDatabaseService graphDbService ) {
    GraphDatabaseAPI graphDb = (GraphDatabaseAPI) graphDbService;
    Kernel kernel = graphDb.getSingleManagementBean( Kernel.class );
    Date startTime = kernel.getKernelStartTime();
    return startTime;
}
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>不同的Neo4j版本，你将使用不同的管理beans设置。</p> 
  <blockquote> 
   <div>
    <ul class="simple"> 
     <li>了解所有Neo4j版本的信息，请参考： <a class="reference external" href="http://components.neo4j.org/neo4j-jmx/1.8/apidocs/org/neo4j/jmx/package-summary.html">org.neo4j.jmx</a> 。</li> 
     <li>了解Neo4j高级版和企业版的信息，请参考： <a class="reference external" href="http://components.neo4j.org/neo4j-management/1.8/apidocs/org/neo4j/management/package-summary.html">org.neo4j.management</a> 。</li> 
    </ul> 
   </div>
  </blockquote> 
 </div>
</blockquote><span id="chapter4-9-index"></span>
<h1>4.9. OSGi配置<a class="headerlink" href="#osgi" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  在 
  <a class="reference external" href="http://www.osgi.org/">OSGi</a> 关联的上下文比如大量的应用服务器（e.g. 
  <a class="reference external" href="http://glassfish.java.net/">Glassfish</a> ）和基于 
  <a class="reference external" href="http://www.eclipse.org">Eclipse</a> 的系统中，Neo4j能被明确地建立起来而不是通过Java服务加载机制来发现。
 </div>
</blockquote> 
<div class="section" id="simple-osgi-activator"> 
 <h2>4.9.1. Simple OSGi Activator 脚本<a class="headerlink" href="#simple-osgi-activator" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>如同在下面的范例中看到的一样，为了代替依赖Neo4j内核的类加载，Neo4j Bundle被作为库 bundles，而像 IndexProviders 和 CacheProviders 这样的服务被明确地实例化，配置和注册了秩序。只需要确保必要的jars，所以所有必须的类都被导出并且包括这Activator。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Neo4jActivator</span> <span class="n">implements</span> <span class="n">BundleActivator</span> <span class="p">{</span>

    <span class="n">private</span> <span class="n">static</span> <span class="n">GraphDatabaseService</span> <span class="n">db</span><span class="p">;</span>
    <span class="n">private</span> <span class="n">ServiceRegistration</span> <span class="n">serviceRegistration</span><span class="p">;</span>
    <span class="n">private</span> <span class="n">ServiceRegistration</span> <span class="n">indexServiceRegistration</span><span class="p">;</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">start</span><span class="p">(</span> <span class="n">BundleContext</span> <span class="n">context</span> <span class="p">)</span> <span class="n">throws</span> <span class="ne">Exception</span>
    <span class="p">{</span>
        <span class="o">//</span><span class="n">the</span> <span class="n">cache</span> <span class="n">providers</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">CacheProvider</span><span class="o">&gt;</span> <span class="n">cacheList</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">CacheProvider</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">cacheList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">new</span> <span class="n">SoftCacheProvider</span><span class="p">()</span> <span class="p">);</span>

        <span class="o">//</span><span class="n">the</span> <span class="n">index</span> <span class="n">providers</span>
        <span class="n">IndexProvider</span> <span class="n">lucene</span> <span class="o">=</span> <span class="n">new</span> <span class="n">LuceneIndexProvider</span><span class="p">();</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">IndexProvider</span><span class="o">&gt;</span> <span class="n">provs</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">IndexProvider</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">provs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">lucene</span> <span class="p">);</span>
        <span class="n">ListIndexIterable</span> <span class="n">providers</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ListIndexIterable</span><span class="p">();</span>
        <span class="n">providers</span><span class="o">.</span><span class="n">setIndexProviders</span><span class="p">(</span> <span class="n">provs</span> <span class="p">);</span>

        <span class="o">//</span><span class="n">the</span> <span class="n">database</span> <span class="n">setup</span>
        <span class="n">GraphDatabaseFactory</span> <span class="n">gdbf</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">();</span>
        <span class="n">gdbf</span><span class="o">.</span><span class="n">setIndexProviders</span><span class="p">(</span> <span class="n">providers</span> <span class="p">);</span>
        <span class="n">gdbf</span><span class="o">.</span><span class="n">setCacheProviders</span><span class="p">(</span> <span class="n">cacheList</span> <span class="p">);</span>
        <span class="n">db</span> <span class="o">=</span> <span class="n">gdbf</span><span class="o">.</span><span class="n">newEmbeddedDatabase</span><span class="p">(</span> <span class="s2">"target/db"</span> <span class="p">);</span>

        <span class="o">//</span><span class="n">the</span> <span class="n">OSGi</span> <span class="n">registration</span>
        <span class="n">serviceRegistration</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">registerService</span><span class="p">(</span>
                <span class="n">GraphDatabaseService</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="n">db</span><span class="p">,</span> <span class="n">new</span> <span class="n">Hashtable</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span> <span class="s2">"registered "</span> <span class="o">+</span> <span class="n">serviceRegistration</span><span class="o">.</span><span class="n">getReference</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">indexServiceRegistration</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">registerService</span><span class="p">(</span>
                <span class="n">Index</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="n">db</span><span class="o">.</span><span class="n">index</span><span class="p">()</span><span class="o">.</span><span class="n">forNodes</span><span class="p">(</span> <span class="s2">"nodes"</span> <span class="p">),</span>
                <span class="n">new</span> <span class="n">Hashtable</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">Transaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">beginTx</span><span class="p">();</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="n">Node</span> <span class="n">firstNode</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
            <span class="n">Node</span> <span class="n">secondNode</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
            <span class="n">Relationship</span> <span class="n">relationship</span> <span class="o">=</span> <span class="n">firstNode</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span>
                    <span class="n">secondNode</span><span class="p">,</span> <span class="n">DynamicRelationshipType</span><span class="o">.</span><span class="n">withName</span><span class="p">(</span> <span class="s2">"KNOWS"</span> <span class="p">)</span> <span class="p">);</span>

            <span class="n">firstNode</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"Hello, "</span> <span class="p">);</span>
            <span class="n">secondNode</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"world!"</span> <span class="p">);</span>
            <span class="n">relationship</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"brave Neo4j "</span> <span class="p">);</span>
            <span class="n">db</span><span class="o">.</span><span class="n">index</span><span class="p">()</span><span class="o">.</span><span class="n">forNodes</span><span class="p">(</span> <span class="s2">"nodes"</span> <span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">firstNode</span><span class="p">,</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"Hello"</span> <span class="p">);</span>
            <span class="n">tx</span><span class="o">.</span><span class="n">success</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">catch</span> <span class="p">(</span> <span class="ne">Exception</span> <span class="n">e</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">e</span><span class="o">.</span><span class="n">printStackTrace</span><span class="p">();</span>
            <span class="n">throw</span> <span class="n">new</span> <span class="n">RuntimeException</span><span class="p">(</span> <span class="n">e</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">finally</span>
        <span class="p">{</span>
            <span class="n">tx</span><span class="o">.</span><span class="n">finish</span><span class="p">();</span>
        <span class="p">}</span>

    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">stop</span><span class="p">(</span> <span class="n">BundleContext</span> <span class="n">context</span> <span class="p">)</span> <span class="n">throws</span> <span class="ne">Exception</span>
    <span class="p">{</span>
        <span class="n">serviceRegistration</span><span class="o">.</span><span class="n">unregister</span><span class="p">();</span>
        <span class="n">indexServiceRegistration</span><span class="o">.</span><span class="n">unregister</span><span class="p">();</span>
        <span class="n">db</span><span class="o">.</span><span class="n">shutdown</span><span class="p">();</span>

    <span class="p">}</span>

<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
  </div>
 </blockquote> 
</div>
<h2>4.9.1. Simple OSGi Activator 脚本<a class="headerlink" href="#simple-osgi-activator" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>如同在下面的范例中看到的一样，为了代替依赖Neo4j内核的类加载，Neo4j Bundle被作为库 bundles，而像 IndexProviders 和 CacheProviders 这样的服务被明确地实例化，配置和注册了秩序。只需要确保必要的jars，所以所有必须的类都被导出并且包括这Activator。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Neo4jActivator</span> <span class="n">implements</span> <span class="n">BundleActivator</span> <span class="p">{</span>

    <span class="n">private</span> <span class="n">static</span> <span class="n">GraphDatabaseService</span> <span class="n">db</span><span class="p">;</span>
    <span class="n">private</span> <span class="n">ServiceRegistration</span> <span class="n">serviceRegistration</span><span class="p">;</span>
    <span class="n">private</span> <span class="n">ServiceRegistration</span> <span class="n">indexServiceRegistration</span><span class="p">;</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">start</span><span class="p">(</span> <span class="n">BundleContext</span> <span class="n">context</span> <span class="p">)</span> <span class="n">throws</span> <span class="ne">Exception</span>
    <span class="p">{</span>
        <span class="o">//</span><span class="n">the</span> <span class="n">cache</span> <span class="n">providers</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">CacheProvider</span><span class="o">&gt;</span> <span class="n">cacheList</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">CacheProvider</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">cacheList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">new</span> <span class="n">SoftCacheProvider</span><span class="p">()</span> <span class="p">);</span>

        <span class="o">//</span><span class="n">the</span> <span class="n">index</span> <span class="n">providers</span>
        <span class="n">IndexProvider</span> <span class="n">lucene</span> <span class="o">=</span> <span class="n">new</span> <span class="n">LuceneIndexProvider</span><span class="p">();</span>
        <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">IndexProvider</span><span class="o">&gt;</span> <span class="n">provs</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">IndexProvider</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="n">provs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">lucene</span> <span class="p">);</span>
        <span class="n">ListIndexIterable</span> <span class="n">providers</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ListIndexIterable</span><span class="p">();</span>
        <span class="n">providers</span><span class="o">.</span><span class="n">setIndexProviders</span><span class="p">(</span> <span class="n">provs</span> <span class="p">);</span>

        <span class="o">//</span><span class="n">the</span> <span class="n">database</span> <span class="n">setup</span>
        <span class="n">GraphDatabaseFactory</span> <span class="n">gdbf</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">();</span>
        <span class="n">gdbf</span><span class="o">.</span><span class="n">setIndexProviders</span><span class="p">(</span> <span class="n">providers</span> <span class="p">);</span>
        <span class="n">gdbf</span><span class="o">.</span><span class="n">setCacheProviders</span><span class="p">(</span> <span class="n">cacheList</span> <span class="p">);</span>
        <span class="n">db</span> <span class="o">=</span> <span class="n">gdbf</span><span class="o">.</span><span class="n">newEmbeddedDatabase</span><span class="p">(</span> <span class="s2">"target/db"</span> <span class="p">);</span>

        <span class="o">//</span><span class="n">the</span> <span class="n">OSGi</span> <span class="n">registration</span>
        <span class="n">serviceRegistration</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">registerService</span><span class="p">(</span>
                <span class="n">GraphDatabaseService</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="n">db</span><span class="p">,</span> <span class="n">new</span> <span class="n">Hashtable</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span> <span class="s2">"registered "</span> <span class="o">+</span> <span class="n">serviceRegistration</span><span class="o">.</span><span class="n">getReference</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">indexServiceRegistration</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">registerService</span><span class="p">(</span>
                <span class="n">Index</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">getName</span><span class="p">(),</span> <span class="n">db</span><span class="o">.</span><span class="n">index</span><span class="p">()</span><span class="o">.</span><span class="n">forNodes</span><span class="p">(</span> <span class="s2">"nodes"</span> <span class="p">),</span>
                <span class="n">new</span> <span class="n">Hashtable</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">Transaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">beginTx</span><span class="p">();</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="n">Node</span> <span class="n">firstNode</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
            <span class="n">Node</span> <span class="n">secondNode</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">createNode</span><span class="p">();</span>
            <span class="n">Relationship</span> <span class="n">relationship</span> <span class="o">=</span> <span class="n">firstNode</span><span class="o">.</span><span class="n">createRelationshipTo</span><span class="p">(</span>
                    <span class="n">secondNode</span><span class="p">,</span> <span class="n">DynamicRelationshipType</span><span class="o">.</span><span class="n">withName</span><span class="p">(</span> <span class="s2">"KNOWS"</span> <span class="p">)</span> <span class="p">);</span>

            <span class="n">firstNode</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"Hello, "</span> <span class="p">);</span>
            <span class="n">secondNode</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"world!"</span> <span class="p">);</span>
            <span class="n">relationship</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"brave Neo4j "</span> <span class="p">);</span>
            <span class="n">db</span><span class="o">.</span><span class="n">index</span><span class="p">()</span><span class="o">.</span><span class="n">forNodes</span><span class="p">(</span> <span class="s2">"nodes"</span> <span class="p">)</span><span class="o">.</span><span class="n">add</span><span class="p">(</span> <span class="n">firstNode</span><span class="p">,</span> <span class="s2">"message"</span><span class="p">,</span> <span class="s2">"Hello"</span> <span class="p">);</span>
            <span class="n">tx</span><span class="o">.</span><span class="n">success</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">catch</span> <span class="p">(</span> <span class="ne">Exception</span> <span class="n">e</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">e</span><span class="o">.</span><span class="n">printStackTrace</span><span class="p">();</span>
            <span class="n">throw</span> <span class="n">new</span> <span class="n">RuntimeException</span><span class="p">(</span> <span class="n">e</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">finally</span>
        <span class="p">{</span>
            <span class="n">tx</span><span class="o">.</span><span class="n">finish</span><span class="p">();</span>
        <span class="p">}</span>

    <span class="p">}</span>

    <span class="nd">@Override</span>
    <span class="n">public</span> <span class="n">void</span> <span class="n">stop</span><span class="p">(</span> <span class="n">BundleContext</span> <span class="n">context</span> <span class="p">)</span> <span class="n">throws</span> <span class="ne">Exception</span>
    <span class="p">{</span>
        <span class="n">serviceRegistration</span><span class="o">.</span><span class="n">unregister</span><span class="p">();</span>
        <span class="n">indexServiceRegistration</span><span class="o">.</span><span class="n">unregister</span><span class="p">();</span>
        <span class="n">db</span><span class="o">.</span><span class="n">shutdown</span><span class="p">();</span>

    <span class="p">}</span>

<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote><span id="chapter4-10-index"></span>
<h1>4.10. 在Java中执行Cypher查询<a class="headerlink" href="#javacypher" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p><strong>提示</strong></p> 
  <blockquote> 
   <div>
    源代码下载地址： 
    <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/cypher/src/test/java/org/neo4j/cypher/javacompat/JavaQuery.java">JavaQuery.java</a>
   </div>
  </blockquote> 
  <p>在Java中，你能使用cypher-query-lang,Cypher查询语言像下面这样：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">GraphDatabaseService</span> <span class="n">db</span> <span class="o">=</span> <span class="n">new</span> <span class="n">GraphDatabaseFactory</span><span class="p">()</span><span class="o">.</span><span class="n">newEmbeddedDatabase</span><span class="p">(</span> <span class="n">DB_PATH</span> <span class="p">);</span>
<span class="o">//</span> <span class="n">add</span> <span class="n">some</span> <span class="n">data</span> <span class="n">first</span>
<span class="n">Transaction</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">beginTx</span><span class="p">();</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="n">refNode</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">getReferenceNode</span><span class="p">();</span>
    <span class="n">refNode</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="s2">"name"</span><span class="p">,</span> <span class="s2">"reference node"</span> <span class="p">);</span>
    <span class="n">tx</span><span class="o">.</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">finally</span>
<span class="p">{</span>
    <span class="n">tx</span><span class="o">.</span><span class="n">finish</span><span class="p">();</span>
<span class="p">}</span>

<span class="o">//</span> <span class="n">let</span><span class="s1">'s execute a query now</span>
<span class="n">ExecutionEngine</span> <span class="n">engine</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ExecutionEngine</span><span class="p">(</span> <span class="n">db</span> <span class="p">);</span>
<span class="n">ExecutionResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span> <span class="s2">"start n=node(0) return n, n.name"</span> <span class="p">);</span>
<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span> <span class="n">result</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>输出结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="o">+---------------------------------------------------+</span>
<span class="o">|</span> <span class="n">n</span>                              <span class="o">|</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span>           <span class="o">|</span>
<span class="o">+---------------------------------------------------+</span>
<span class="o">|</span> <span class="n">Node</span><span class="p">[</span><span class="mi">0</span><span class="p">]{</span><span class="n">name</span><span class="p">:</span><span class="s2">"reference node"</span><span class="p">}</span> <span class="o">|</span> <span class="s2">"reference node"</span> <span class="o">|</span>
<span class="o">+---------------------------------------------------+</span>
<span class="mi">1</span> <span class="n">row</span>
<span class="mi">0</span> <span class="n">ms</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>注意：在这使用的类来自于 <code class="docutils literal"><span class="pre">org.neo4j.cypher.javacompat</span></code> 包，而不是 <code class="docutils literal"><span class="pre">org.neo4j.cypher</span></code> ，通过下面的链接查看Java API。</p> 
  <p>你可以在结果中获取列的一个列表：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">();</span>
<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span> <span class="n">columns</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>输出结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在单列中获取结果数据集，像下面这样：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">n_column</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columnAs</span><span class="p">(</span> <span class="s2">"n"</span> <span class="p">);</span>
<span class="k">for</span> <span class="p">(</span> <span class="n">Node</span> <span class="n">node</span> <span class="p">:</span> <span class="n">IteratorUtil</span><span class="o">.</span><span class="n">asIterable</span><span class="p">(</span> <span class="n">n_column</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="o">//</span> <span class="n">note</span><span class="p">:</span> <span class="n">we</span><span class="s1">'re grabbing the name property from the node,</span>
    <span class="o">//</span> <span class="ow">not</span> <span class="kn">from</span> <span class="nn">the</span> <span class="nn">n.name</span> <span class="nn">in</span> <span class="nn">this</span> <span class="nn">case.</span>
    <span class="n">nodeResult</span> <span class="o">=</span> <span class="n">node</span> <span class="o">+</span> <span class="s2">": "</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">);</span>
    <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span> <span class="n">nodeResult</span> <span class="p">);</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在这种情况下结果中只有一个几个记录：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Node</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">reference</span> <span class="n">node</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>要获取所有的列，用下面的代替：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7
8</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">row</span> <span class="p">:</span> <span class="n">result</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">column</span> <span class="p">:</span> <span class="n">row</span><span class="o">.</span><span class="n">entrySet</span><span class="p">()</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">rows</span> <span class="o">+=</span> <span class="n">column</span><span class="o">.</span><span class="n">getKey</span><span class="p">()</span> <span class="o">+</span> <span class="s2">": "</span> <span class="o">+</span> <span class="n">column</span><span class="o">.</span><span class="n">getValue</span><span class="p">()</span> <span class="o">+</span> <span class="s2">"; "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">rows</span> <span class="o">+=</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span> <span class="n">rows</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>输出结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">reference</span> <span class="n">node</span><span class="p">;</span> <span class="n">n</span><span class="p">:</span> <span class="n">Node</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>要获取Java接口中关于Cypher的更多信息，请参考：<a class="reference external" href="http://components.neo4j.org/neo4j-cypher/1.8/apidocs/index.html">Java API</a>。</p> 
  <p>要获取更多关于Cypher的范例的信息，请参考： cypher-query-lang 和 data-modeling-examples。</p> 
 </div>
</blockquote><span id="chapter5-index"></span>
<h1>第 5 章 Neo4j远程客户端库<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>包括Java范例在内的这些内容向我们展示了一个在Java中使用Neo4j REST API的更“低级”的方法。</p> 
  <p>要获取更多信息，请浏览下面的介绍。</p> 
 </div>
</blockquote> 
<div class="toctree-wrapper compound"> 
 <ul> 
  <li class="toctree-l1"><a class="reference internal" href="chapter5_1.html">5.1. 由社区贡献的Neo4j REST客户端</a></li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter5_2.html">5.2. 在Java中如何使用REST API</a>
   <ul> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#rest-api">5.2.1. 通过 REST API 创建一个图数据库</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#id1">5.2.2. 启动图数据库服务器</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#id2">5.2.3. 创建一个节点</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#id3">5.2.4. 增加属性</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#id4">5.2.5. 增加关系</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#id5">5.2.6. 给关系增加属性</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#id6">5.2.7. 从图数据库中查询数据</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#id7">5.2.8. 喔，是这样吗？==</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#id8">5.2.9. 下一步计划是什么呢？</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter5_2.html#id9">5.2.10. 附录：代码</a></li> 
   </ul> </li> 
 </ul> 
</div><span id="chapter5-1-index"></span>
<h1>5.1. 由社区贡献的Neo4j REST客户端<a class="headerlink" href="#neo4j-rest" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p><cite>表 5.1. 由社区贡献的Neo4j REST客户端。</cite></p> 
  <table border="1" class="docutils"> 
   <colgroup> 
    <col width="24%"> 
    <col width="14%"> 
    <col width="61%"> 
   </colgroup> 
   <thead valign="bottom"> 
    <tr class="row-odd">
     <th class="head">名称</th> 
     <th class="head">语言 / 框架</th> 
     <th class="head">地址</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr class="row-even">
     <td>Java-Rest-Binding</td> 
     <td>Java</td> 
     <td><a class="reference external" href="https://github.com/neo4j/java-rest-binding/">https://github.com/neo4j/java-rest-binding/</a></td> 
    </tr> 
    <tr class="row-odd">
     <td>Neo4jClient</td> 
     <td>.NET</td> 
     <td><a class="reference external" href="http://hg.readify.net/neo4jclient/">http://hg.readify.net/neo4jclient/</a></td> 
    </tr> 
    <tr class="row-even">
     <td>Neo4jRestNet</td> 
     <td>.NET</td> 
     <td><a class="reference external" href="https://github.com/SepiaGroup/Neo4jRestNet">https://github.com/SepiaGroup/Neo4jRestNet</a></td> 
    </tr> 
    <tr class="row-odd">
     <td>py2neo</td> 
     <td>Python</td> 
     <td><a class="reference external" href="http://py2neo.org/">http://py2neo.org/</a></td> 
    </tr> 
    <tr class="row-even">
     <td>Bulbflow</td> 
     <td>Python</td> 
     <td><a class="reference external" href="http://bulbflow.com/">http://bulbflow.com/</a></td> 
    </tr> 
    <tr class="row-odd">
     <td>neo4jrestclient</td> 
     <td>Python</td> 
     <td><a class="reference external" href="https://github.com/versae/neo4j-rest-client">https://github.com/versae/neo4j-rest-client</a></td> 
    </tr> 
    <tr class="row-even">
     <td>neo4django</td> 
     <td>Django</td> 
     <td><a class="reference external" href="https://github.com/scholrly/neo4django">https://github.com/scholrly/neo4django</a></td> 
    </tr> 
    <tr class="row-odd">
     <td>Neo4jPHP</td> 
     <td>PHP</td> 
     <td><a class="reference external" href="https://github.com/jadell/Neo4jPHP">https://github.com/jadell/Neo4jPHP</a></td> 
    </tr> 
    <tr class="row-even">
     <td>neography</td> 
     <td>Ruby</td> 
     <td><a class="reference external" href="https://github.com/maxdemarzi/neography">https://github.com/maxdemarzi/neography</a></td> 
    </tr> 
    <tr class="row-odd">
     <td>Neoid</td> 
     <td>Ruby</td> 
     <td><a class="reference external" href="https://github.com/elado/neoid">https://github.com/elado/neoid</a></td> 
    </tr> 
    <tr class="row-even">
     <td>node.js</td> 
     <td>JavaScript</td> 
     <td><a class="reference external" href="https://github.com/thingdom/node-neo4j">https://github.com/thingdom/node-neo4j</a></td> 
    </tr> 
    <tr class="row-odd">
     <td>Neocons</td> 
     <td>Clojure</td> 
     <td><a class="reference external" href="https://github.com/michaelklishin/neocons">https://github.com/michaelklishin/neocons</a></td> 
    </tr> 
   </tbody> 
  </table> 
 </div>
</blockquote><span id="chapter5-2-index"></span>
<h1>5.2. 在Java中如何使用REST API<a class="headerlink" href="#javarest-api" title="Permalink to this headline"></a></h1> 
<div class="section" id="rest-api"> 
 <h2>5.2.1. 通过 REST API 创建一个图数据库<a class="headerlink" href="#rest-api" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>REST API使用 <cite>HTTP</cite> 协议和 <cite>JSON</cite> 数据格式，以至于它能用于多种语言和平台。当准备开始使用的时候，看一些可以被重用的模式也是非常有帮助的。在这个简短的概述中，我们将为你展示如何使用 REST API 创建和维护一个简单的图数据库并且如何从中查询数据。</p> 
   <p>对于这些范例，我们选择了 <a class="reference external" href="http://jersey.java.net/">Jersey</a> 客户端组件，这个组件之前我们已经通过 <cite>Maven</cite> 下载了。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id1"> 
 <h2>5.2.2. 启动图数据库服务器<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>在我们对服务器做任何操作之前，我们需要启动它。了解服务器安装的详细信息，请参考：<strong>server-installation</strong> 。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>WebResource resource = Client.create()
    .resource( SERVER_ROOT_URI );
ClientResponse response = resource.get( ClientResponse.class );

System.out.println( String.format( "GET on [%s], status code [%d]",
        SERVER_ROOT_URI, response.getStatus() ) );
response.close();
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>如果返回状态码是 <code class="docutils literal"><span class="pre">200</span> <span class="pre">OK</span></code> ，那我们知道服务器已经运行良好而我们也能继续了。如果连接到服务器失败，请参考：server。</p> 
   <p>注意：如果你得到任何大于 <code class="docutils literal"><span class="pre">200</span> <span class="pre">OK</span></code> （特别是 <code class="docutils literal"><span class="pre">4xx</span></code> 和 <code class="docutils literal"><span class="pre">5xx</span></code> ）的返回码，那么请检查你的配置并且查看在目录 <cite>‘data/log’</cite> 的日志文件。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id2"> 
 <h2>5.2.3. 创建一个节点<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>REST API使用+POST+方式创建节点。在Java中使用Jersey客户端封装是很简单的：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>final String nodeEntryPointUri = SERVER_ROOT_URI + "node";
// http://localhost:7474/db/data/node

WebResource resource = Client.create()
        .resource( nodeEntryPointUri );
// POST {} to the node entry point URI
ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
        .type( MediaType.APPLICATION_JSON )
        .entity( "{}" )
        .post( ClientResponse.class );

final URI location = response.getLocation();
System.out.println( String.format(
        "POST to [%s], status code [%d], location header [%s]",
        nodeEntryPointUri, response.getStatus(), location.toString() ) );
response.close();

return location;
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>如果请求成功完成，它会在后台发送一个包括 <cite>JSON</cite> 格式的数据的 <cite>HTTP</cite> 请求到图数据库服务器。这服务器将会在数据库中创建一个新的节点并且返回一个状态码 <code class="docutils literal"><span class="pre">201</span> <span class="pre">Created</span></code> 和一个包含新节点地址的 <code class="docutils literal"><span class="pre">Location</span></code> 头信息。</p> 
   <p>在我们的范例中，我们将调用两次这个功能以便在我们的数据库中创建两个节点。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id3"> 
 <h2>5.2.4. 增加属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>一旦我们在我们的数据库中有了节点，我们能用他们存储有用的数据。在这种情况下，我们将在我们的数据库中存储关于音乐的信息。让我们先看看我们创建节点和增加属性的代码。这儿我们已经增加了一个节点用来表示 <cite>Joe Strummer</cite> 和一个乐队 <cite>The Clash</cite> 。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">URI</span> <span class="n">firstNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">();</span>
<span class="n">addProperty</span><span class="p">(</span> <span class="n">firstNode</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">,</span> <span class="s2">"Joe Strummer"</span> <span class="p">);</span>
<span class="n">URI</span> <span class="n">secondNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">();</span>
<span class="n">addProperty</span><span class="p">(</span> <span class="n">secondNode</span><span class="p">,</span> <span class="s2">"band"</span><span class="p">,</span> <span class="s2">"The Clash"</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>在 +addProperty+方法内部我们确定了表示节点属性的资源以及这个属性的名称。我们然后 +PUT+那个属性的值到服务器。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>String propertyUri = nodeUri.toString() + "/properties/" + propertyName;
// http://localhost:7474/db/data/node/{node_id}/properties/{property_name}

WebResource resource = Client.create()
        .resource( propertyUri );
ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
        .type( MediaType.APPLICATION_JSON )
        .entity( "\"" + propertyValue + "\"" )
        .put( ClientResponse.class );

System.out.println( String.format( "PUT to [%s], status code [%d]",
        propertyUri, response.getStatus() ) );
response.close();
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>如果一切运行正常，我们将得到一个 <code class="docutils literal"><span class="pre">204</span> <span class="pre">No</span> <span class="pre">Content</span></code> 的返回码表示服务器已经处理了我们的情况但并不会回显属性的值。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id4"> 
 <h2>5.2.5. 增加关系<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>现在我们有了表示 <cite>Joe Strummer</cite> 和 <cite>The Clash</cite> 的节点，我们将给他们建立关系。 REST API支持通过一个 <strong>POST</strong> 请求来为节点间建立关系。在Java中与此相对应，我们 <strong>POST</strong> 一些JSON数据到表示 <cite>Joe Strummer</cite> 的节点的地址上面，来确定一个该节点和表示 <cite>The Clash</cite> 的节点之前的关系。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">URI</span> <span class="n">relationshipUri</span> <span class="o">=</span> <span class="n">addRelationship</span><span class="p">(</span> <span class="n">firstNode</span><span class="p">,</span> <span class="n">secondNode</span><span class="p">,</span> <span class="s2">"singer"</span><span class="p">,</span>
    <span class="s2">"{ </span><span class="se">\"</span><span class="s2">from</span><span class="se">\"</span><span class="s2"> : </span><span class="se">\"</span><span class="s2">1976</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">until</span><span class="se">\"</span><span class="s2"> : </span><span class="se">\"</span><span class="s2">1986</span><span class="se">\"</span><span class="s2"> }"</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>在 <code class="docutils literal"><span class="pre">addRelationship()</span></code> 方法内部，我们确定了节点 <cite>Joe Strummer</cite> 的关系的URI，然后 <strong>POST</strong> 了一个 <cite>JSON</cite> 数据到服务器。这个 <cite>JSON</cite> 数据包括目标节点，关系类型以及其他任何属性。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>private static URI addRelationship( URI startNode, URI endNode,
        String relationshipType, String jsonAttributes )
        throws URISyntaxException {
    URI fromUri = new URI( startNode.toString() + "/relationships" );
    String relationshipJson = generateJsonRelationship( endNode,
            relationshipType, jsonAttributes );

    WebResource resource = Client.create()
            .resource( fromUri );
    // POST JSON to the relationships URI
    ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
            .type( MediaType.APPLICATION_JSON )
            .entity( relationshipJson )
            .post( ClientResponse.class );

    final URI location = response.getLocation();
    System.out.println( String.format(
            "POST to [%s], status code [%d], location header [%s]",
            fromUri, response.getStatus(), location.toString() ) );

    response.close();
    return location;
}
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>如果一切运行正常，我们将收到一个状态码 <code class="docutils literal"><span class="pre">201</span> <span class="pre">Created</span></code> 并且一个我们刚创建的关系的URI在 <cite>HTTP</cite> 头里面的 <code class="docutils literal"><span class="pre">Location</span></code> 。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id5"> 
 <h2>5.2.6. 给关系增加属性<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>像节点一样，关系也可以有属性。因为我们是 <cite>Joe Strummer</cite> 和 <cite>the Clash</cite> 的超级大粉丝，我们将增加一个评价属性到关系上面以至于其他人能看到这个乐队的5星级歌手。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">addMetadataToProperty</span><span class="p">(</span> <span class="n">relationshipUri</span><span class="p">,</span> <span class="s2">"stars"</span><span class="p">,</span> <span class="s2">"5"</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>在 <code class="docutils literal"><span class="pre">addMetadataToProperty()</span></code> 方法内部，我们确定关系的属性的URI，并且 <strong>PUT</strong> 我们的新值到服务器（因为它是 <strong>PUT</strong> 所以它总是会覆盖已经存在的值，所以一定要小心）。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>private static void addMetadataToProperty( URI relationshipUri,
        String name, String value ) throws URISyntaxException
{
    URI propertyUri = new URI( relationshipUri.toString() + "/properties" );
    String entity = toJsonNameValuePairCollection( name, value );
    WebResource resource = Client.create()
            .resource( propertyUri );
    ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
            .type( MediaType.APPLICATION_JSON )
            .entity( entity )
            .put( ClientResponse.class );

    System.out.println( String.format(
            "PUT [%s] to [%s], status code [%d]", entity, propertyUri,
            response.getStatus() ) );
    response.close();
}
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>假设一切运行正常，我们将得到一个 <code class="docutils literal"><span class="pre">200</span> <span class="pre">OK</span></code> 返回码（我们也可以调用 <code class="docutils literal"><span class="pre">ClientResponse.getStatus()</span></code> 来获取）而且我们现在可以确定我们已经可以从一个小型图数据库中查询数据了。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id6"> 
 <h2>5.2.7. 从图数据库中查询数据<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>作为图数据库的嵌入模式，Neo4j服务器使用图遍历来在途中查询数据。当前Neo4j服务器期望一个 <cite>JSON</cite> 数据通过 <strong>POST</strong> 发送过来进行遍历查询（虽然这也可以改变成 <strong>GET</strong> 的方式）。</p> 
   <p>要启动这个进程，我们用一个简单的类来封装 <cite>JSON</cite> 数据并通过 <strong>POST</strong> 发送到服务器，在这种情况下我们硬编码遍历查询来查找所有带有输出方向关系 <cite>“singer”</cite> 的所有节点。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="o">//</span> <span class="n">TraversalDescription</span> <span class="n">turns</span> <span class="n">into</span> <span class="n">JSON</span> <span class="n">to</span> <span class="n">send</span> <span class="n">to</span> <span class="n">the</span> <span class="n">Server</span>
<span class="n">TraversalDescription</span> <span class="n">t</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TraversalDescription</span><span class="p">();</span>
<span class="n">t</span><span class="o">.</span><span class="n">setOrder</span><span class="p">(</span> <span class="n">TraversalDescription</span><span class="o">.</span><span class="n">DEPTH_FIRST</span> <span class="p">);</span>
<span class="n">t</span><span class="o">.</span><span class="n">setUniqueness</span><span class="p">(</span> <span class="n">TraversalDescription</span><span class="o">.</span><span class="n">NODE</span> <span class="p">);</span>
<span class="n">t</span><span class="o">.</span><span class="n">setMaxDepth</span><span class="p">(</span> <span class="mi">10</span> <span class="p">);</span>
<span class="n">t</span><span class="o">.</span><span class="n">setReturnFilter</span><span class="p">(</span> <span class="n">TraversalDescription</span><span class="o">.</span><span class="n">ALL</span> <span class="p">);</span>
<span class="n">t</span><span class="o">.</span><span class="n">setRelationships</span><span class="p">(</span> <span class="n">new</span> <span class="n">Relationship</span><span class="p">(</span> <span class="s2">"singer"</span><span class="p">,</span> <span class="n">Relationship</span><span class="o">.</span><span class="n">OUT</span> <span class="p">)</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>一旦我们定义了我们的遍历查询所需的参数，我们只需要传递它。我们先确定起始节点的遍历查询的URI，然后 +POST+遍历查询的JSON数据来完成这个需求。</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span>URI traverserUri = new URI( startNode.toString() + "/traverse/node" );
WebResource resource = Client.create()
        .resource( traverserUri );
String jsonTraverserPayload = t.toJson();
ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
        .type( MediaType.APPLICATION_JSON )
        .entity( jsonTraverserPayload )
        .post( ClientResponse.class );

System.out.println( String.format(
        "POST [%s] to [%s], status code [%d], returned data: "
                + System.getProperty( "line.separator" ) + "%s",
        jsonTraverserPayload, traverserUri, response.getStatus(),
        response.getEntity( String.class ) ) );
response.close();
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>一旦请求被完成，我们将得到歌手的数据集以及他们所属的乐队：</p> 
   <div class="highlight-json">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="p">[</span> <span class="p">{</span>
    <span class="nt">"outgoing_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/out"</span><span class="p">,</span>
    <span class="nt">"data"</span> <span class="p">:</span> <span class="p">{</span>
      <span class="nt">"band"</span> <span class="p">:</span> <span class="s2">"The Clash"</span><span class="p">,</span>
      <span class="nt">"name"</span> <span class="p">:</span> <span class="s2">"Joe Strummer"</span>
    <span class="p">},</span>
    <span class="nt">"traverse"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/traverse/{returnType}"</span><span class="p">,</span>
    <span class="nt">"all_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/all/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"property"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/properties/{key}"</span><span class="p">,</span>
    <span class="nt">"all_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/all"</span><span class="p">,</span>
    <span class="nt">"self"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82"</span><span class="p">,</span>
    <span class="nt">"properties"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/properties"</span><span class="p">,</span>
    <span class="nt">"outgoing_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/out/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"incoming_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/in"</span><span class="p">,</span>
    <span class="nt">"incoming_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/in/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"create_relationship"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships"</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="nt">"outgoing_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/out"</span><span class="p">,</span>
    <span class="nt">"data"</span> <span class="p">:</span> <span class="p">{</span>
    <span class="p">},</span>
    <span class="nt">"traverse"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/traverse/{returnType}"</span><span class="p">,</span>
    <span class="nt">"all_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/all/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"property"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/properties/{key}"</span><span class="p">,</span>
    <span class="nt">"all_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/all"</span><span class="p">,</span>
    <span class="nt">"self"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83"</span><span class="p">,</span>
    <span class="nt">"properties"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/properties"</span><span class="p">,</span>
    <span class="nt">"outgoing_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/out/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"incoming_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/in"</span><span class="p">,</span>
    <span class="nt">"incoming_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/in/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"create_relationship"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships"</span>
  <span class="p">}</span>
<span class="p">]</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id7"> 
 <h2>5.2.8. 喔，是这样吗？==<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>那是我们用 <strong>REST API</strong> 做我们的事情的方式。</p> 
   <p>自然而然的我们提交到服务器的任何 <cite>HTTP</cite> 语义都很容易被封装，包括通过 <code class="docutils literal"><span class="pre">DELETE</span></code> 来移除节点和关系。不过，如果你已经完全掌握了，那么在 <cite>Jersey</cite> 客户端从 <code class="docutils literal"><span class="pre">.delete()</span></code> 切换成 <code class="docutils literal"><span class="pre">.delete()</span></code> 是非常容易的。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id8"> 
 <h2>5.2.9. 下一步计划是什么呢？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p><strong>HTTP API</strong> 提供一个客户端库更好的基本实现，它也是优秀的基于 <cite>HTTP</cite> 的 <strong>REST</strong> 接口。</p> 
   <p>比起提供友好的语言级的开发架构实现，尽管他们能非常简单的绑定来使用嵌入模式的图数据库，我们还是计划在将来让常用语言都提供基于 <strong>REST API</strong> 的客户端绑定实现。要了解当前各种语言的 <cite>Neo4j REST</cite> 客户端实现以及嵌入封装，请参考： <a class="reference external" href="http://www.delicious.com/neo4j/drivers">http://www.delicious.com/neo4j/drivers</a> 。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id9"> 
 <h2>5.2.10. 附录：代码<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <ul class="simple"> 
    <li><a class="reference external" href="https://github.com/neo4j/community/blob/1.8/server-examples/src/main/java/org/neo4j/examples/server/CreateSimpleGraph.java">CreateSimpleGraph.java</a></li> 
    <li><a class="reference external" href="https://github.com/neo4j/community/blob/1.8/server-examples/src/main/java/org/neo4j/examples/server/Relationship.java">Relationship.java</a></li> 
    <li><a class="reference external" href="https://github.com/neo4j/community/blob/1.8/server-examples/src/main/java/org/neo4j/examples/server/TraversalDescription.java">TraversalDescription.java</a></li> 
   </ul> 
  </div>
 </blockquote> 
</div>
<h2>5.2.1. 通过 REST API 创建一个图数据库<a class="headerlink" href="#rest-api" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>REST API使用 <cite>HTTP</cite> 协议和 <cite>JSON</cite> 数据格式，以至于它能用于多种语言和平台。当准备开始使用的时候，看一些可以被重用的模式也是非常有帮助的。在这个简短的概述中，我们将为你展示如何使用 REST API 创建和维护一个简单的图数据库并且如何从中查询数据。</p> 
  <p>对于这些范例，我们选择了 <a class="reference external" href="http://jersey.java.net/">Jersey</a> 客户端组件，这个组件之前我们已经通过 <cite>Maven</cite> 下载了。</p> 
 </div>
</blockquote>
<h2>5.2.2. 启动图数据库服务器<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>在我们对服务器做任何操作之前，我们需要启动它。了解服务器安装的详细信息，请参考：<strong>server-installation</strong> 。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>WebResource resource = Client.create()
    .resource( SERVER_ROOT_URI );
ClientResponse response = resource.get( ClientResponse.class );

System.out.println( String.format( "GET on [%s], status code [%d]",
        SERVER_ROOT_URI, response.getStatus() ) );
response.close();
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>如果返回状态码是 <code class="docutils literal"><span class="pre">200</span> <span class="pre">OK</span></code> ，那我们知道服务器已经运行良好而我们也能继续了。如果连接到服务器失败，请参考：server。</p> 
  <p>注意：如果你得到任何大于 <code class="docutils literal"><span class="pre">200</span> <span class="pre">OK</span></code> （特别是 <code class="docutils literal"><span class="pre">4xx</span></code> 和 <code class="docutils literal"><span class="pre">5xx</span></code> ）的返回码，那么请检查你的配置并且查看在目录 <cite>‘data/log’</cite> 的日志文件。</p> 
 </div>
</blockquote>
<h2>5.2.3. 创建一个节点<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>REST API使用+POST+方式创建节点。在Java中使用Jersey客户端封装是很简单的：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>final String nodeEntryPointUri = SERVER_ROOT_URI + "node";
// http://localhost:7474/db/data/node

WebResource resource = Client.create()
        .resource( nodeEntryPointUri );
// POST {} to the node entry point URI
ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
        .type( MediaType.APPLICATION_JSON )
        .entity( "{}" )
        .post( ClientResponse.class );

final URI location = response.getLocation();
System.out.println( String.format(
        "POST to [%s], status code [%d], location header [%s]",
        nodeEntryPointUri, response.getStatus(), location.toString() ) );
response.close();

return location;
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>如果请求成功完成，它会在后台发送一个包括 <cite>JSON</cite> 格式的数据的 <cite>HTTP</cite> 请求到图数据库服务器。这服务器将会在数据库中创建一个新的节点并且返回一个状态码 <code class="docutils literal"><span class="pre">201</span> <span class="pre">Created</span></code> 和一个包含新节点地址的 <code class="docutils literal"><span class="pre">Location</span></code> 头信息。</p> 
  <p>在我们的范例中，我们将调用两次这个功能以便在我们的数据库中创建两个节点。</p> 
 </div>
</blockquote>
<h2>5.2.4. 增加属性<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>一旦我们在我们的数据库中有了节点，我们能用他们存储有用的数据。在这种情况下，我们将在我们的数据库中存储关于音乐的信息。让我们先看看我们创建节点和增加属性的代码。这儿我们已经增加了一个节点用来表示 <cite>Joe Strummer</cite> 和一个乐队 <cite>The Clash</cite> 。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">URI</span> <span class="n">firstNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">();</span>
<span class="n">addProperty</span><span class="p">(</span> <span class="n">firstNode</span><span class="p">,</span> <span class="s2">"name"</span><span class="p">,</span> <span class="s2">"Joe Strummer"</span> <span class="p">);</span>
<span class="n">URI</span> <span class="n">secondNode</span> <span class="o">=</span> <span class="n">createNode</span><span class="p">();</span>
<span class="n">addProperty</span><span class="p">(</span> <span class="n">secondNode</span><span class="p">,</span> <span class="s2">"band"</span><span class="p">,</span> <span class="s2">"The Clash"</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在 +addProperty+方法内部我们确定了表示节点属性的资源以及这个属性的名称。我们然后 +PUT+那个属性的值到服务器。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>String propertyUri = nodeUri.toString() + "/properties/" + propertyName;
// http://localhost:7474/db/data/node/{node_id}/properties/{property_name}

WebResource resource = Client.create()
        .resource( propertyUri );
ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
        .type( MediaType.APPLICATION_JSON )
        .entity( "\"" + propertyValue + "\"" )
        .put( ClientResponse.class );

System.out.println( String.format( "PUT to [%s], status code [%d]",
        propertyUri, response.getStatus() ) );
response.close();
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>如果一切运行正常，我们将得到一个 <code class="docutils literal"><span class="pre">204</span> <span class="pre">No</span> <span class="pre">Content</span></code> 的返回码表示服务器已经处理了我们的情况但并不会回显属性的值。</p> 
 </div>
</blockquote>
<h2>5.2.5. 增加关系<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>现在我们有了表示 <cite>Joe Strummer</cite> 和 <cite>The Clash</cite> 的节点，我们将给他们建立关系。 REST API支持通过一个 <strong>POST</strong> 请求来为节点间建立关系。在Java中与此相对应，我们 <strong>POST</strong> 一些JSON数据到表示 <cite>Joe Strummer</cite> 的节点的地址上面，来确定一个该节点和表示 <cite>The Clash</cite> 的节点之前的关系。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">URI</span> <span class="n">relationshipUri</span> <span class="o">=</span> <span class="n">addRelationship</span><span class="p">(</span> <span class="n">firstNode</span><span class="p">,</span> <span class="n">secondNode</span><span class="p">,</span> <span class="s2">"singer"</span><span class="p">,</span>
    <span class="s2">"{ </span><span class="se">\"</span><span class="s2">from</span><span class="se">\"</span><span class="s2"> : </span><span class="se">\"</span><span class="s2">1976</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">until</span><span class="se">\"</span><span class="s2"> : </span><span class="se">\"</span><span class="s2">1986</span><span class="se">\"</span><span class="s2"> }"</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在 <code class="docutils literal"><span class="pre">addRelationship()</span></code> 方法内部，我们确定了节点 <cite>Joe Strummer</cite> 的关系的URI，然后 <strong>POST</strong> 了一个 <cite>JSON</cite> 数据到服务器。这个 <cite>JSON</cite> 数据包括目标节点，关系类型以及其他任何属性。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>private static URI addRelationship( URI startNode, URI endNode,
        String relationshipType, String jsonAttributes )
        throws URISyntaxException {
    URI fromUri = new URI( startNode.toString() + "/relationships" );
    String relationshipJson = generateJsonRelationship( endNode,
            relationshipType, jsonAttributes );

    WebResource resource = Client.create()
            .resource( fromUri );
    // POST JSON to the relationships URI
    ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
            .type( MediaType.APPLICATION_JSON )
            .entity( relationshipJson )
            .post( ClientResponse.class );

    final URI location = response.getLocation();
    System.out.println( String.format(
            "POST to [%s], status code [%d], location header [%s]",
            fromUri, response.getStatus(), location.toString() ) );

    response.close();
    return location;
}
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>如果一切运行正常，我们将收到一个状态码 <code class="docutils literal"><span class="pre">201</span> <span class="pre">Created</span></code> 并且一个我们刚创建的关系的URI在 <cite>HTTP</cite> 头里面的 <code class="docutils literal"><span class="pre">Location</span></code> 。</p> 
 </div>
</blockquote>
<h2>5.2.6. 给关系增加属性<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>像节点一样，关系也可以有属性。因为我们是 <cite>Joe Strummer</cite> 和 <cite>the Clash</cite> 的超级大粉丝，我们将增加一个评价属性到关系上面以至于其他人能看到这个乐队的5星级歌手。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">addMetadataToProperty</span><span class="p">(</span> <span class="n">relationshipUri</span><span class="p">,</span> <span class="s2">"stars"</span><span class="p">,</span> <span class="s2">"5"</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在 <code class="docutils literal"><span class="pre">addMetadataToProperty()</span></code> 方法内部，我们确定关系的属性的URI，并且 <strong>PUT</strong> 我们的新值到服务器（因为它是 <strong>PUT</strong> 所以它总是会覆盖已经存在的值，所以一定要小心）。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>private static void addMetadataToProperty( URI relationshipUri,
        String name, String value ) throws URISyntaxException
{
    URI propertyUri = new URI( relationshipUri.toString() + "/properties" );
    String entity = toJsonNameValuePairCollection( name, value );
    WebResource resource = Client.create()
            .resource( propertyUri );
    ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
            .type( MediaType.APPLICATION_JSON )
            .entity( entity )
            .put( ClientResponse.class );

    System.out.println( String.format(
            "PUT [%s] to [%s], status code [%d]", entity, propertyUri,
            response.getStatus() ) );
    response.close();
}
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>假设一切运行正常，我们将得到一个 <code class="docutils literal"><span class="pre">200</span> <span class="pre">OK</span></code> 返回码（我们也可以调用 <code class="docutils literal"><span class="pre">ClientResponse.getStatus()</span></code> 来获取）而且我们现在可以确定我们已经可以从一个小型图数据库中查询数据了。</p> 
 </div>
</blockquote>
<h2>5.2.7. 从图数据库中查询数据<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>作为图数据库的嵌入模式，Neo4j服务器使用图遍历来在途中查询数据。当前Neo4j服务器期望一个 <cite>JSON</cite> 数据通过 <strong>POST</strong> 发送过来进行遍历查询（虽然这也可以改变成 <strong>GET</strong> 的方式）。</p> 
  <p>要启动这个进程，我们用一个简单的类来封装 <cite>JSON</cite> 数据并通过 <strong>POST</strong> 发送到服务器，在这种情况下我们硬编码遍历查询来查找所有带有输出方向关系 <cite>“singer”</cite> 的所有节点。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="o">//</span> <span class="n">TraversalDescription</span> <span class="n">turns</span> <span class="n">into</span> <span class="n">JSON</span> <span class="n">to</span> <span class="n">send</span> <span class="n">to</span> <span class="n">the</span> <span class="n">Server</span>
<span class="n">TraversalDescription</span> <span class="n">t</span> <span class="o">=</span> <span class="n">new</span> <span class="n">TraversalDescription</span><span class="p">();</span>
<span class="n">t</span><span class="o">.</span><span class="n">setOrder</span><span class="p">(</span> <span class="n">TraversalDescription</span><span class="o">.</span><span class="n">DEPTH_FIRST</span> <span class="p">);</span>
<span class="n">t</span><span class="o">.</span><span class="n">setUniqueness</span><span class="p">(</span> <span class="n">TraversalDescription</span><span class="o">.</span><span class="n">NODE</span> <span class="p">);</span>
<span class="n">t</span><span class="o">.</span><span class="n">setMaxDepth</span><span class="p">(</span> <span class="mi">10</span> <span class="p">);</span>
<span class="n">t</span><span class="o">.</span><span class="n">setReturnFilter</span><span class="p">(</span> <span class="n">TraversalDescription</span><span class="o">.</span><span class="n">ALL</span> <span class="p">);</span>
<span class="n">t</span><span class="o">.</span><span class="n">setRelationships</span><span class="p">(</span> <span class="n">new</span> <span class="n">Relationship</span><span class="p">(</span> <span class="s2">"singer"</span><span class="p">,</span> <span class="n">Relationship</span><span class="o">.</span><span class="n">OUT</span> <span class="p">)</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>一旦我们定义了我们的遍历查询所需的参数，我们只需要传递它。我们先确定起始节点的遍历查询的URI，然后 +POST+遍历查询的JSON数据来完成这个需求。</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span>URI traverserUri = new URI( startNode.toString() + "/traverse/node" );
WebResource resource = Client.create()
        .resource( traverserUri );
String jsonTraverserPayload = t.toJson();
ClientResponse response = resource.accept( MediaType.APPLICATION_JSON )
        .type( MediaType.APPLICATION_JSON )
        .entity( jsonTraverserPayload )
        .post( ClientResponse.class );

System.out.println( String.format(
        "POST [%s] to [%s], status code [%d], returned data: "
                + System.getProperty( "line.separator" ) + "%s",
        jsonTraverserPayload, traverserUri, response.getStatus(),
        response.getEntity( String.class ) ) );
response.close();
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>一旦请求被完成，我们将得到歌手的数据集以及他们所属的乐队：</p> 
  <div class="highlight-json">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="p">[</span> <span class="p">{</span>
    <span class="nt">"outgoing_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/out"</span><span class="p">,</span>
    <span class="nt">"data"</span> <span class="p">:</span> <span class="p">{</span>
      <span class="nt">"band"</span> <span class="p">:</span> <span class="s2">"The Clash"</span><span class="p">,</span>
      <span class="nt">"name"</span> <span class="p">:</span> <span class="s2">"Joe Strummer"</span>
    <span class="p">},</span>
    <span class="nt">"traverse"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/traverse/{returnType}"</span><span class="p">,</span>
    <span class="nt">"all_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/all/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"property"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/properties/{key}"</span><span class="p">,</span>
    <span class="nt">"all_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/all"</span><span class="p">,</span>
    <span class="nt">"self"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82"</span><span class="p">,</span>
    <span class="nt">"properties"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/properties"</span><span class="p">,</span>
    <span class="nt">"outgoing_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/out/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"incoming_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/in"</span><span class="p">,</span>
    <span class="nt">"incoming_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships/in/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"create_relationship"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/82/relationships"</span>
  <span class="p">},</span> <span class="p">{</span>
    <span class="nt">"outgoing_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/out"</span><span class="p">,</span>
    <span class="nt">"data"</span> <span class="p">:</span> <span class="p">{</span>
    <span class="p">},</span>
    <span class="nt">"traverse"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/traverse/{returnType}"</span><span class="p">,</span>
    <span class="nt">"all_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/all/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"property"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/properties/{key}"</span><span class="p">,</span>
    <span class="nt">"all_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/all"</span><span class="p">,</span>
    <span class="nt">"self"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83"</span><span class="p">,</span>
    <span class="nt">"properties"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/properties"</span><span class="p">,</span>
    <span class="nt">"outgoing_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/out/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"incoming_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/in"</span><span class="p">,</span>
    <span class="nt">"incoming_typed_relationships"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships/in/{-list|&amp;|types}"</span><span class="p">,</span>
    <span class="nt">"create_relationship"</span> <span class="p">:</span> <span class="s2">"http://localhost:7474/db/data/node/83/relationships"</span>
  <span class="p">}</span>
<span class="p">]</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
 </div>
</blockquote>
<h2>5.2.8. 喔，是这样吗？==<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>那是我们用 <strong>REST API</strong> 做我们的事情的方式。</p> 
  <p>自然而然的我们提交到服务器的任何 <cite>HTTP</cite> 语义都很容易被封装，包括通过 <code class="docutils literal"><span class="pre">DELETE</span></code> 来移除节点和关系。不过，如果你已经完全掌握了，那么在 <cite>Jersey</cite> 客户端从 <code class="docutils literal"><span class="pre">.delete()</span></code> 切换成 <code class="docutils literal"><span class="pre">.delete()</span></code> 是非常容易的。</p> 
 </div>
</blockquote>
<h2>5.2.9. 下一步计划是什么呢？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p><strong>HTTP API</strong> 提供一个客户端库更好的基本实现，它也是优秀的基于 <cite>HTTP</cite> 的 <strong>REST</strong> 接口。</p> 
  <p>比起提供友好的语言级的开发架构实现，尽管他们能非常简单的绑定来使用嵌入模式的图数据库，我们还是计划在将来让常用语言都提供基于 <strong>REST API</strong> 的客户端绑定实现。要了解当前各种语言的 <cite>Neo4j REST</cite> 客户端实现以及嵌入封装，请参考： <a class="reference external" href="http://www.delicious.com/neo4j/drivers">http://www.delicious.com/neo4j/drivers</a> 。</p> 
 </div>
</blockquote>
<h2>5.2.10. 附录：代码<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <ul class="simple"> 
   <li><a class="reference external" href="https://github.com/neo4j/community/blob/1.8/server-examples/src/main/java/org/neo4j/examples/server/CreateSimpleGraph.java">CreateSimpleGraph.java</a></li> 
   <li><a class="reference external" href="https://github.com/neo4j/community/blob/1.8/server-examples/src/main/java/org/neo4j/examples/server/Relationship.java">Relationship.java</a></li> 
   <li><a class="reference external" href="https://github.com/neo4j/community/blob/1.8/server-examples/src/main/java/org/neo4j/examples/server/TraversalDescription.java">TraversalDescription.java</a></li> 
  </ul> 
 </div>
</blockquote><span id="id1"></span>
<h1>第 6 章 遍历查询框架<a class="headerlink" href="#chapter6-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>在Java中的 Neo4j Traversal API是基于回调机制的，懒加载执行的。一些遍历查询范例收集正这里：<a class="reference internal" href="../chapter4/chapter4_5.html#chapter4-5-index"><span class="std std-ref">第 4.5 节 遍历查询</span></a> 。</p> 
  <p>在Neo4j中其他一些遍历和查询方式还有 <cite>cypher-query-lang</cite> , <cite>Cypher</cite> 和 <cite>gremlin-plugin</cite> , <cite>Gremlin</cite>。</p> 
 </div>
</blockquote> 
<div class="toctree-wrapper compound"> 
 <ul> 
  <li class="toctree-l1"><a class="reference internal" href="chapter6_1.html">6.1. 主要观点</a></li> 
  <li class="toctree-l1"><a class="reference internal" href="chapter6_2.html">6.2. 遍历查询框架 Java API</a>
   <ul> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#traversaldescription">6.2.1. TraversalDescription</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#evaluator">6.2.2. Evaluator</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#traverser">6.2.3. Traverser</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#uniqueness">6.2.4. Uniqueness</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#order">6.2.5. Order—如何穿过分支呢？</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#branchselector">6.2.6. BranchSelector</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#path">6.2.7. Path</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#pathexpander-relationshipexpander">6.2.8. PathExpander/RelationshipExpander</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#expander">6.2.9. Expander</a></li> 
    <li class="toctree-l2"><a class="reference internal" href="chapter6_2.html#id6">6.2.10. 如何使用遍历查询框架</a></li> 
   </ul> </li> 
 </ul> 
</div><span id="id1"></span>
<h1>6.1. 主要观点<a class="headerlink" href="#chapter6-1-index" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>下面对各种修改遍历描述对象的方法进行一个简短的说明。</p> 
  <ul class="simple"> 
   <li>Expanders 定义遍历的内容，特别是关系的方向和类型。</li> 
   <li>Order 比如宽度优先或者深度优先。</li> 
   <li>Uniqueness 只访问一次节点（关系，路径）。</li> 
   <li>Evaluator 决定返回的内容以及在超过当前位置是否继续遍历。</li> 
   <li>Starting nodes 决定遍历的起点。</li> 
  </ul> 
  <div class="figure"> 
   <img alt="../_images/image6.1.png" src="../_images/image6.1.png"> 
  </div> 
  <p>更多细节请查看： <a class="reference internal" href="chapter6_2.html#chapter6-2-index"><span class="std std-ref">第 6.2 节 遍历查询框架 Java API</span></a></p> 
 </div>
</blockquote><span id="chapter6-2-index"></span>
<h1>6.2. 遍历查询框架 Java API<a class="headerlink" href="#java-api" title="Permalink to this headline"></a></h1> 
<blockquote> 
 <div>
  <p>除了 Node 和 Relationship 遍历查询框架还包括一些主要的接口:</p> 
  <blockquote> 
   <div>
    <cite>TraversalDescription</cite> ，
    <cite>Evaluator</cite> ，
    <cite>Traverser</cite> 和 
    <cite>Uniqueness</cite> 是一些主要的。
   </div>
  </blockquote> 
  <p>Path接口在遍历中还有一个特殊的用途，因为当评估该位置时它常被用来表示在图中的一个位置。</p> 
  <p>此外， <cite>PathExpander</cite> (代替 <cite>RelationshipExpander</cite> ) 和 <cite>Expander</cite> 接口是遍历框架中的核心，但API的用户很少需要自己去实现它们。对于高级应用，也有一个设置接口，当需要精确控制遍历的顺序的时候，可以采用： <cite>BranchSelector</cite> , <cite>BranchOrderingPolicy</cite> 和 <cite>TraversalBranch</cite> 。</p> 
 </div>
</blockquote> 
<div class="section" id="traversaldescription"> 
 <h2>6.2.1. TraversalDescription<a class="headerlink" href="#traversaldescription" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p><cite>TraversalDescription</cite> 是用来定义和初始化遍历查询的非常重要的接口。这并不是说要用户去实现遍历查询框架，而是相对于有框架提供的实现来说，这提供了一个用户自定义查询条件的方法。 <cite>TraversalDescription</cite> 实例是不可改变的而它的方法返回一个新的 <cite>TraversalDescription</cite> 实例是可以改变的。</p> 
   <p><strong>Relationships</strong></p> 
   <blockquote> 
    <div>
     增加一个关系类型到遍历的关系类型列表中。默认情况下，这个列表是空的，意味着默认会返回所有类型的关系，而不考虑类型。如果有关系被加入到这个列表中，那就意味着只有列表中的关系才会被遍历。有两个方法，一个是 
     <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html">包括方向</a> ，另外一个是 
     <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html">排除方向</a> ，这个方法中遍历关系是 
     <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/Direction.html">双向</a> 的。
    </div>
   </blockquote> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="evaluator"> 
 <h2>6.2.2. Evaluator<a class="headerlink" href="#evaluator" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>大量的Evaluator是用来决定在每一个位置（用一个 <cite>Path</cite> 表示）：是应该继续遍历查询以及节点是否包括在结果中。对于一个给定的 <cite>Path</cite> ，它要求对遍历查询分支采用下面四个动作中的一种：</p> 
   <ul class="simple"> 
    <li><strong>Evaluation.INCLUDE_AND_CONTINUE</strong> : 包括这个节点在结果中并且继续遍历查询。</li> 
    <li><strong>Evaluation.INCLUDE_AND_PRUNE</strong> : 包括这个节点在结果中并且继续不遍历查询。</li> 
    <li><strong>Evaluation.EXCLUDE_AND_CONTINUE</strong> : 排除这个节点在结果中并且继续遍历查询。</li> 
    <li><strong>Evaluation.EXCLUDE_AND_PRUNE</strong> : 排除这个节点在结果中并且继续不遍历查询。</li> 
   </ul> 
   <p><cite>Evaluator</cite> 可以加入多个。注意 <cite>Evaluator</cite> 将被遍历过程中遇到的每一个位置所调用，甚至包括起点节点。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="traverser"> 
 <h2>6.2.3. Traverser<a class="headerlink" href="#traverser" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p><a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/traversal/Traverser.html">Traverser</a> 对象是调用一个 <cite>TraversalDescription</cite> 的 <code class="docutils literal"><span class="pre">traverse()</span></code> 方法返回的结果。</p> 
   <p>它表示正一个图数据库中遍历的位置集合和结果格式化的一个规范。实际的遍历在每次的执行中都是懒加载的，只有当我们调用 <cite>Traverser</cite> 的方法 <code class="docutils literal"><span class="pre">next()</span></code> 时才会被真正执行。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="uniqueness"> 
 <h2>6.2.4. Uniqueness<a class="headerlink" href="#uniqueness" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>在Uniqueness中说明了一个设置规则，这个规则决定在一个遍历期间如何访问已经访问过的位置策略。默认规则是 <strong>NODE_GLOBAL</strong> 。</p> 
   <p>一个 <cite>Uniqueness</cite> 能提供给 <cite>TraversalDescription</cite> ,用来决定一个遍历是否重新可以访问相同的位置。不同的策略级别可以使用：</p> 
   <ul class="simple"> 
    <li><strong>NONE</strong> ：在图数据库中任何节点都可以被重访。</li> 
    <li><strong>NODE_GLOBAL uniqueness</strong> ：在图数据库中每个节点只能被访问一次。这会潜在的消耗大量的内存因为图要求保持一个内存中的数据结构用来保存所有被访问过的节点。</li> 
    <li><strong>RELATIONSHIP_GLOBAL uniqueness</strong> ：在图数据库中每个关系只能被访问一次。这会潜在的消耗大量的内存因为图中一般关系的数量远远大于节点的数量。这种级别的内存开销会增长得更快。</li> 
    <li><strong>NODE_PATH uniqueness</strong> ：一个节点不能在之前的遍历路径中出现过。</li> 
    <li><strong>RELATIONSHIP_PATH uniqueness</strong> ：一个关系不能在之前的遍历路径中出现过。</li> 
    <li><strong>NODE_RECENT uniqueness</strong> ：这是 NODE_GLOBAL uniqueness 的简化版，有一个全局访问过的节点集合在每个位置进行核对。这种级别不会消耗大量的内存因为这个集合只会包含最近访问过的节点。这个集合的尺寸可以通过方法 TraversalDescription.uniqueness() 的第二个参数来指定。</li> 
    <li><strong>RELATIONSHIP_RECENT uniqueness</strong> ：跟节点类似，只是换成关系而已。</li> 
   </ul> 
   <p><strong>Depth First / Breadth First</strong></p> 
   <blockquote> 
    <div>
     有很多方法可以设置顺序的 
     <cite>BranchSelector|ordering</cite> 策略：
     <code class="docutils literal"><span class="pre">depth-first/</span> <span class="pre">breadth-first</span></code> 。相同的结果可以通过调用 
     <cite>Traversal factory</cite> 的 
     <code class="docutils literal"><span class="pre">order</span></code> ，也可以新建自己的 
     <cite>BranchSelector/BranchOrderingPolicy</cite> 并传入完成。
    </div>
   </blockquote> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="order"> 
 <h2>6.2.5. Order—如何穿过分支呢？<a class="headerlink" href="#order" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <cite>depthFirst/breadthFirst</cite> 方法的普通版本是允许一个任意的 
   <cite>BranchOrderingPolicy</cite> 注入到 
   <cite>TraversalDescription</cite> 。
  </div>
 </blockquote> 
</div> 
<div class="section" id="branchselector"> 
 <h2>6.2.6. BranchSelector<a class="headerlink" href="#branchselector" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>一个BranchSelector是用来定义如何选择遍历下一个分支。这被用来实现遍历顺序。遍历框架提供了一些基本的顺序实现：</p> 
   <ul class="simple"> 
    <li><code class="docutils literal"><span class="pre">Traversal.preorderDepthFirst()</span></code> : 深度优先，在访问的子节点之前访问每一个节点。</li> 
    <li><code class="docutils literal"><span class="pre">Traversal.postorderDepthFirst()</span></code> : 深度优先，在访问的子节点之后访问每一个节点。</li> 
    <li><code class="docutils literal"><span class="pre">Traversal.preorderBreadthFirst()</span></code> : 宽度优先，在访问的子节点之前访问每一个节点。</li> 
    <li><code class="docutils literal"><span class="pre">Traversal.postorderBreadthFirst()</span></code> : 宽度优先，在访问的子节点之后访问每一个节点。</li> 
   </ul> 
   <p><strong>注意</strong> ：请注意宽度优先遍历策略比深度优先策略消耗更多的内存。</p> 
   <p><cite>BranchSelectors</cite> 带有状态信息因此需要正每一次遍历的时候都被唯一实例化。因此，它被通过一个 <cite>BranchOrderingPolicy</cite> 接口来提供给 <cite>TraversalDescription</cite> ，而它是一个 <cite>BranchSelector</cite> 实例化工厂。</p> 
   <p>遍历查询框架的用户很少需要实现图自己的 <cite>BranchSelector</cite> 和 <cite>BranchOrderingPolicy</cite> ，它们让图形算法实现者提供它们自己的遍历顺序。Neo4j图算法包包含了一个最好优先（ <cite>BestFirst</cite> ）的 <cite>BranchSelector/BranchOrderingPolicy</cite> 实现，常用于 <strong>A*</strong> 和 <strong>Dijkstra</strong> 算法中。</p> 
   <p><strong>BranchOrderingPolicy</strong></p> 
   <blockquote> 
    <div>
     <p>它是一个工厂，用来创建 <cite>BranchSelectors</cite> 决定哪些分支需要返回（一个分支的位置常用 <cite>Path</cite> 来表示）。一般策略是 <cite>depth-first</cite> 和 <cite>breadth-first</cite>。举个例子，调用 <code class="docutils literal"><span class="pre">TraversalDescription#depthFirst()</span></code> 等价于：</p> 
     <div class="highlight-python">
      <table class="highlighttable">
       <tbody>
        <tr>
         <td class="linenos">
          <div class="linenodiv">
           <pre>1</pre>
          </div></td>
         <td class="code">
          <div class="highlight">
           <pre><span></span><span class="n">description</span><span class="o">.</span><span class="n">order</span><span class="p">(</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">preorderDepthFirst</span><span class="p">()</span> <span class="p">);</span>
</pre>
          </div> </td>
        </tr>
       </tbody>
      </table>
     </div> 
    </div>
   </blockquote> 
   <p><strong>TraversalBranch</strong></p> 
   <blockquote> 
    <div>
     被 
     <cite>BranchSelector</cite> 使用的一个对象用来从一个给定的分支获取更多分支。本质上，有一个由一个路径和一个 
     <cite>RelationshipExpander</cite> 组成， 
     <cite>RelationshipExpander</cite> 能被用来从当前的分支获取新的 
     <cite>TraversalBranch</cite> 。
    </div>
   </blockquote> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="path"> 
 <h2>6.2.7. Path<a class="headerlink" href="#path" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   一个 
   <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/Path.html">Path</a> 是 
   <strong>Neo4j API</strong> 中的一个普通接口。在Neo4j遍历查询API中，
   <cite>Path</cite> 的用法有两方面。 
   <cite>Traversers</cite> 可以以 
   <cite>Path</cite> 的形式返回它们在图中被标记为要返回的结果。 
   <cite>Path</cite> 对象也可以用于正图中进行位置评估，决定一个遍历在某个点是否继续和某个点是否被包含在结果中。
  </div>
 </blockquote> 
</div> 
<div class="section" id="pathexpander-relationshipexpander"> 
 <h2>6.2.8. PathExpander/RelationshipExpander<a class="headerlink" href="#pathexpander-relationshipexpander" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   遍历查询框架用 
   <cite>PathExpanders`（取代 `RelationshipExpander</cite> ）查找在遍历查询中从一个特别的路径到更多的分支应跟随的关系。
  </div>
 </blockquote> 
</div> 
<div class="section" id="expander"> 
 <h2>6.2.9. Expander<a class="headerlink" href="#expander" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>注入+RelationshipExpander+的关系的一个更通用的版本，定义了所有要被遍历节点的所有关系。默认情况下，一个 <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/kernel/Traversal.html#emptyExpander">default expander</a> 被使用，这个时候任何关系的方向都不考虑。</p> 
   <p>有另外一个实现方法，担保遍历的关系类型都在order of relationship type中。</p> 
   <p><cite>Expander</cite> 接口是 <cite>RelationshipExpander</cite> 接口的一个扩展确保能自定义一个 <cite>Expander</cite> 。 <cite>TraversalDescription</cite> 用这个来提供方法定义遍历的关系类型，这是一个API用户用来定义一个 <cite>RelationshipExpander</cite> 不常用的方法—在 <cite>TraversalDescription</cite> 内部构造它。</p> 
   <p>通过Neo4j遍历查询框架提供的所有 <cite>RelationshipExpanders</cite> 也实现了 <cite>Expander</cite> 接口，因为它之包含一个方法—这个方法从一个路径/节点获取关系，<cite>Expander</cite> 接口增加的方法只能用于构件新的 <cite>Expanders</cite> 。</p> 
  </div>
 </blockquote> 
</div> 
<div class="section" id="id6"> 
 <h2>6.2.10. 如何使用遍历查询框架<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <blockquote> 
  <div>
   <p>与 <cite>Node#traverse</cite> 相反，一个 <cite>traversal description</cite> 被构造而它能产生一个 <cite>traversers</cite> 。</p> 
   <p><cite>图 6.1. 遍历查询范例数据库</cite></p> 
   <div class="figure"> 
    <img alt="../_images/image6.2.png" src="../_images/image6.2.png"> 
   </div> 
   <p><cite>RelationshipTypes</cite> 的定义如下：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">private</span> <span class="n">enum</span> <span class="n">Rels</span> <span class="n">implements</span> <span class="n">RelationshipType</span> <span class="p">{</span>
    <span class="n">LIKES</span><span class="p">,</span> <span class="n">KNOWS</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>图数据库可以被下面范例的遍历查询器便利，从 <cite>Joe</cite> 节点开始：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7
8</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">position</span> <span class="p">:</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
        <span class="o">.</span><span class="n">depthFirst</span><span class="p">()</span>
        <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">Rels</span><span class="o">.</span><span class="n">KNOWS</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">Rels</span><span class="o">.</span><span class="n">LIKES</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">INCOMING</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">toDepth</span><span class="p">(</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">position</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>遍历后输出结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>因为 <cite>TraversalDescription</cite> 是不可以改变的因此创建一个描述模板来在不同的遍历器中共享是非常游泳的，比如，让他们从这个遍历器开始：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">final</span> <span class="n">TraversalDescription</span> <span class="n">FRIENDS_TRAVERSAL</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
    <span class="o">.</span><span class="n">depthFirst</span><span class="p">()</span>
    <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">Rels</span><span class="o">.</span><span class="n">KNOWS</span> <span class="p">)</span>
    <span class="o">.</span><span class="n">uniqueness</span><span class="p">(</span> <span class="n">Uniqueness</span><span class="o">.</span><span class="n">RELATIONSHIP_GLOBAL</span> <span class="p">);</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>这个遍历器将会输出下面的结果（我们始终保持从节点 <cite>Joe</cite> 开始）：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>现在让我们从它上面创建一个新的遍历器，严格规定深度为3：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">:</span> <span class="n">FRIENDS_TRAVERSAL</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">toDepth</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">path</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>这会返回这样的结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>或者我们把深度从2变成4又会怎么样呢？下面是我们的测试：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">:</span> <span class="n">FRIENDS_TRAVERSAL</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">fromDepth</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">toDepth</span><span class="p">(</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">path</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>这个遍历器会返回这样的结果：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>要获取各种不同有用的evaluators，请参考： Evaluators Java API 。或者自己简单实现 Evaluator接口。</p> 
   <p>如果你对 Path 没有兴趣，但对 Node 有兴趣，你可以转换遍历器成一个 节点的迭代器，像下面这样：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Node</span> <span class="n">currentNode</span> <span class="p">:</span> <span class="n">FRIENDS_TRAVERSAL</span>
<span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span>
<span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>在这种情况下我们使用它来接收名称：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6
7</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">Joe</span>
<span class="n">Sara</span>
<span class="n">Peter</span>
<span class="n">Dirk</span>
<span class="n">Lars</span>
<span class="n">Ed</span>
<span class="n">Lisa</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>Relationships 也同样可以这样，下面是我们如何得到他们</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Relationship</span> <span class="n">relationship</span> <span class="p">:</span> <span class="n">FRIENDS_TRAVERSAL</span>
        <span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">relationships</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">relationship</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>这儿是书写的关系类型，我们将得到他们：</p> 
   <div class="highlight-python">
    <table class="highlighttable">
     <tbody>
      <tr>
       <td class="linenos">
        <div class="linenodiv">
         <pre>1
2
3
4
5
6</pre>
        </div></td>
       <td class="code">
        <div class="highlight">
         <pre><span></span><span class="n">KNOWS</span>
<span class="n">KNOWS</span>
<span class="n">KNOWS</span>
<span class="n">KNOWS</span>
<span class="n">KNOWS</span>
<span class="n">KNOWS</span>
</pre>
        </div> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>在这个范例中的遍历器的源代码下载地址： <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/TraversalExample.java">TraversalExample.java</a> 。</p> 
  </div>
 </blockquote> 
</div>
<h2>6.2.1. TraversalDescription<a class="headerlink" href="#traversaldescription" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p><cite>TraversalDescription</cite> 是用来定义和初始化遍历查询的非常重要的接口。这并不是说要用户去实现遍历查询框架，而是相对于有框架提供的实现来说，这提供了一个用户自定义查询条件的方法。 <cite>TraversalDescription</cite> 实例是不可改变的而它的方法返回一个新的 <cite>TraversalDescription</cite> 实例是可以改变的。</p> 
  <p><strong>Relationships</strong></p> 
  <blockquote> 
   <div>
    增加一个关系类型到遍历的关系类型列表中。默认情况下，这个列表是空的，意味着默认会返回所有类型的关系，而不考虑类型。如果有关系被加入到这个列表中，那就意味着只有列表中的关系才会被遍历。有两个方法，一个是 
    <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html">包括方向</a> ，另外一个是 
    <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/traversal/TraversalDescription.html">排除方向</a> ，这个方法中遍历关系是 
    <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/Direction.html">双向</a> 的。
   </div>
  </blockquote> 
 </div>
</blockquote>
<h2>6.2.2. Evaluator<a class="headerlink" href="#evaluator" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>大量的Evaluator是用来决定在每一个位置（用一个 <cite>Path</cite> 表示）：是应该继续遍历查询以及节点是否包括在结果中。对于一个给定的 <cite>Path</cite> ，它要求对遍历查询分支采用下面四个动作中的一种：</p> 
  <ul class="simple"> 
   <li><strong>Evaluation.INCLUDE_AND_CONTINUE</strong> : 包括这个节点在结果中并且继续遍历查询。</li> 
   <li><strong>Evaluation.INCLUDE_AND_PRUNE</strong> : 包括这个节点在结果中并且继续不遍历查询。</li> 
   <li><strong>Evaluation.EXCLUDE_AND_CONTINUE</strong> : 排除这个节点在结果中并且继续遍历查询。</li> 
   <li><strong>Evaluation.EXCLUDE_AND_PRUNE</strong> : 排除这个节点在结果中并且继续不遍历查询。</li> 
  </ul> 
  <p><cite>Evaluator</cite> 可以加入多个。注意 <cite>Evaluator</cite> 将被遍历过程中遇到的每一个位置所调用，甚至包括起点节点。</p> 
 </div>
</blockquote>
<h2>6.2.3. Traverser<a class="headerlink" href="#traverser" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p><a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/traversal/Traverser.html">Traverser</a> 对象是调用一个 <cite>TraversalDescription</cite> 的 <code class="docutils literal"><span class="pre">traverse()</span></code> 方法返回的结果。</p> 
  <p>它表示正一个图数据库中遍历的位置集合和结果格式化的一个规范。实际的遍历在每次的执行中都是懒加载的，只有当我们调用 <cite>Traverser</cite> 的方法 <code class="docutils literal"><span class="pre">next()</span></code> 时才会被真正执行。</p> 
 </div>
</blockquote>
<h2>6.2.4. Uniqueness<a class="headerlink" href="#uniqueness" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>在Uniqueness中说明了一个设置规则，这个规则决定在一个遍历期间如何访问已经访问过的位置策略。默认规则是 <strong>NODE_GLOBAL</strong> 。</p> 
  <p>一个 <cite>Uniqueness</cite> 能提供给 <cite>TraversalDescription</cite> ,用来决定一个遍历是否重新可以访问相同的位置。不同的策略级别可以使用：</p> 
  <ul class="simple"> 
   <li><strong>NONE</strong> ：在图数据库中任何节点都可以被重访。</li> 
   <li><strong>NODE_GLOBAL uniqueness</strong> ：在图数据库中每个节点只能被访问一次。这会潜在的消耗大量的内存因为图要求保持一个内存中的数据结构用来保存所有被访问过的节点。</li> 
   <li><strong>RELATIONSHIP_GLOBAL uniqueness</strong> ：在图数据库中每个关系只能被访问一次。这会潜在的消耗大量的内存因为图中一般关系的数量远远大于节点的数量。这种级别的内存开销会增长得更快。</li> 
   <li><strong>NODE_PATH uniqueness</strong> ：一个节点不能在之前的遍历路径中出现过。</li> 
   <li><strong>RELATIONSHIP_PATH uniqueness</strong> ：一个关系不能在之前的遍历路径中出现过。</li> 
   <li><strong>NODE_RECENT uniqueness</strong> ：这是 NODE_GLOBAL uniqueness 的简化版，有一个全局访问过的节点集合在每个位置进行核对。这种级别不会消耗大量的内存因为这个集合只会包含最近访问过的节点。这个集合的尺寸可以通过方法 TraversalDescription.uniqueness() 的第二个参数来指定。</li> 
   <li><strong>RELATIONSHIP_RECENT uniqueness</strong> ：跟节点类似，只是换成关系而已。</li> 
  </ul> 
  <p><strong>Depth First / Breadth First</strong></p> 
  <blockquote> 
   <div>
    有很多方法可以设置顺序的 
    <cite>BranchSelector|ordering</cite> 策略：
    <code class="docutils literal"><span class="pre">depth-first/</span> <span class="pre">breadth-first</span></code> 。相同的结果可以通过调用 
    <cite>Traversal factory</cite> 的 
    <code class="docutils literal"><span class="pre">order</span></code> ，也可以新建自己的 
    <cite>BranchSelector/BranchOrderingPolicy</cite> 并传入完成。
   </div>
  </blockquote> 
 </div>
</blockquote>
<h2>6.2.5. Order—如何穿过分支呢？<a class="headerlink" href="#order" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <cite>depthFirst/breadthFirst</cite> 方法的普通版本是允许一个任意的 
  <cite>BranchOrderingPolicy</cite> 注入到 
  <cite>TraversalDescription</cite> 。
 </div>
</blockquote>
<h2>6.2.6. BranchSelector<a class="headerlink" href="#branchselector" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>一个BranchSelector是用来定义如何选择遍历下一个分支。这被用来实现遍历顺序。遍历框架提供了一些基本的顺序实现：</p> 
  <ul class="simple"> 
   <li><code class="docutils literal"><span class="pre">Traversal.preorderDepthFirst()</span></code> : 深度优先，在访问的子节点之前访问每一个节点。</li> 
   <li><code class="docutils literal"><span class="pre">Traversal.postorderDepthFirst()</span></code> : 深度优先，在访问的子节点之后访问每一个节点。</li> 
   <li><code class="docutils literal"><span class="pre">Traversal.preorderBreadthFirst()</span></code> : 宽度优先，在访问的子节点之前访问每一个节点。</li> 
   <li><code class="docutils literal"><span class="pre">Traversal.postorderBreadthFirst()</span></code> : 宽度优先，在访问的子节点之后访问每一个节点。</li> 
  </ul> 
  <p><strong>注意</strong> ：请注意宽度优先遍历策略比深度优先策略消耗更多的内存。</p> 
  <p><cite>BranchSelectors</cite> 带有状态信息因此需要正每一次遍历的时候都被唯一实例化。因此，它被通过一个 <cite>BranchOrderingPolicy</cite> 接口来提供给 <cite>TraversalDescription</cite> ，而它是一个 <cite>BranchSelector</cite> 实例化工厂。</p> 
  <p>遍历查询框架的用户很少需要实现图自己的 <cite>BranchSelector</cite> 和 <cite>BranchOrderingPolicy</cite> ，它们让图形算法实现者提供它们自己的遍历顺序。Neo4j图算法包包含了一个最好优先（ <cite>BestFirst</cite> ）的 <cite>BranchSelector/BranchOrderingPolicy</cite> 实现，常用于 <strong>A*</strong> 和 <strong>Dijkstra</strong> 算法中。</p> 
  <p><strong>BranchOrderingPolicy</strong></p> 
  <blockquote> 
   <div>
    <p>它是一个工厂，用来创建 <cite>BranchSelectors</cite> 决定哪些分支需要返回（一个分支的位置常用 <cite>Path</cite> 来表示）。一般策略是 <cite>depth-first</cite> 和 <cite>breadth-first</cite>。举个例子，调用 <code class="docutils literal"><span class="pre">TraversalDescription#depthFirst()</span></code> 等价于：</p> 
    <div class="highlight-python">
     <table class="highlighttable">
      <tbody>
       <tr>
        <td class="linenos">
         <div class="linenodiv">
          <pre>1</pre>
         </div></td>
        <td class="code">
         <div class="highlight">
          <pre><span></span><span class="n">description</span><span class="o">.</span><span class="n">order</span><span class="p">(</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">preorderDepthFirst</span><span class="p">()</span> <span class="p">);</span>
</pre>
         </div> </td>
       </tr>
      </tbody>
     </table>
    </div> 
   </div>
  </blockquote> 
  <p><strong>TraversalBranch</strong></p> 
  <blockquote> 
   <div>
    被 
    <cite>BranchSelector</cite> 使用的一个对象用来从一个给定的分支获取更多分支。本质上，有一个由一个路径和一个 
    <cite>RelationshipExpander</cite> 组成， 
    <cite>RelationshipExpander</cite> 能被用来从当前的分支获取新的 
    <cite>TraversalBranch</cite> 。
   </div>
  </blockquote> 
 </div>
</blockquote>
<h2>6.2.7. Path<a class="headerlink" href="#path" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  一个 
  <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/graphdb/Path.html">Path</a> 是 
  <strong>Neo4j API</strong> 中的一个普通接口。在Neo4j遍历查询API中，
  <cite>Path</cite> 的用法有两方面。 
  <cite>Traversers</cite> 可以以 
  <cite>Path</cite> 的形式返回它们在图中被标记为要返回的结果。 
  <cite>Path</cite> 对象也可以用于正图中进行位置评估，决定一个遍历在某个点是否继续和某个点是否被包含在结果中。
 </div>
</blockquote>
<h2>6.2.8. PathExpander/RelationshipExpander<a class="headerlink" href="#pathexpander-relationshipexpander" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  遍历查询框架用 
  <cite>PathExpanders`（取代 `RelationshipExpander</cite> ）查找在遍历查询中从一个特别的路径到更多的分支应跟随的关系。
 </div>
</blockquote>
<h2>6.2.9. Expander<a class="headerlink" href="#expander" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>注入+RelationshipExpander+的关系的一个更通用的版本，定义了所有要被遍历节点的所有关系。默认情况下，一个 <a class="reference external" href="http://components.neo4j.org/neo4j/1.8/apidocs/org/neo4j/kernel/Traversal.html#emptyExpander">default expander</a> 被使用，这个时候任何关系的方向都不考虑。</p> 
  <p>有另外一个实现方法，担保遍历的关系类型都在order of relationship type中。</p> 
  <p><cite>Expander</cite> 接口是 <cite>RelationshipExpander</cite> 接口的一个扩展确保能自定义一个 <cite>Expander</cite> 。 <cite>TraversalDescription</cite> 用这个来提供方法定义遍历的关系类型，这是一个API用户用来定义一个 <cite>RelationshipExpander</cite> 不常用的方法—在 <cite>TraversalDescription</cite> 内部构造它。</p> 
  <p>通过Neo4j遍历查询框架提供的所有 <cite>RelationshipExpanders</cite> 也实现了 <cite>Expander</cite> 接口，因为它之包含一个方法—这个方法从一个路径/节点获取关系，<cite>Expander</cite> 接口增加的方法只能用于构件新的 <cite>Expanders</cite> 。</p> 
 </div>
</blockquote>
<h2>6.2.10. 如何使用遍历查询框架<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<blockquote> 
 <div>
  <p>与 <cite>Node#traverse</cite> 相反，一个 <cite>traversal description</cite> 被构造而它能产生一个 <cite>traversers</cite> 。</p> 
  <p><cite>图 6.1. 遍历查询范例数据库</cite></p> 
  <div class="figure"> 
   <img alt="../_images/image6.2.png" src="../_images/image6.2.png"> 
  </div> 
  <p><cite>RelationshipTypes</cite> 的定义如下：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">private</span> <span class="n">enum</span> <span class="n">Rels</span> <span class="n">implements</span> <span class="n">RelationshipType</span> <span class="p">{</span>
    <span class="n">LIKES</span><span class="p">,</span> <span class="n">KNOWS</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>图数据库可以被下面范例的遍历查询器便利，从 <cite>Joe</cite> 节点开始：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7
8</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">position</span> <span class="p">:</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
        <span class="o">.</span><span class="n">depthFirst</span><span class="p">()</span>
        <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">Rels</span><span class="o">.</span><span class="n">KNOWS</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">Rels</span><span class="o">.</span><span class="n">LIKES</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">INCOMING</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">toDepth</span><span class="p">(</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">position</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>遍历后输出结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">LIKES</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>因为 <cite>TraversalDescription</cite> 是不可以改变的因此创建一个描述模板来在不同的遍历器中共享是非常游泳的，比如，让他们从这个遍历器开始：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">final</span> <span class="n">TraversalDescription</span> <span class="n">FRIENDS_TRAVERSAL</span> <span class="o">=</span> <span class="n">Traversal</span><span class="o">.</span><span class="n">description</span><span class="p">()</span>
    <span class="o">.</span><span class="n">depthFirst</span><span class="p">()</span>
    <span class="o">.</span><span class="n">relationships</span><span class="p">(</span> <span class="n">Rels</span><span class="o">.</span><span class="n">KNOWS</span> <span class="p">)</span>
    <span class="o">.</span><span class="n">uniqueness</span><span class="p">(</span> <span class="n">Uniqueness</span><span class="o">.</span><span class="n">RELATIONSHIP_GLOBAL</span> <span class="p">);</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>这个遍历器将会输出下面的结果（我们始终保持从节点 <cite>Joe</cite> 开始）：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>现在让我们从它上面创建一个新的遍历器，严格规定深度为3：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">:</span> <span class="n">FRIENDS_TRAVERSAL</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">toDepth</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">path</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>这会返回这样的结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>或者我们把深度从2变成4又会怎么样呢？下面是我们的测试：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Path</span> <span class="n">path</span> <span class="p">:</span> <span class="n">FRIENDS_TRAVERSAL</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">fromDepth</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">evaluator</span><span class="p">(</span> <span class="n">Evaluators</span><span class="o">.</span><span class="n">toDepth</span><span class="p">(</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">path</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>这个遍历器会返回这样的结果：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="o">--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">--&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="o">&lt;--</span><span class="p">[</span><span class="n">KNOWS</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">--</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>要获取各种不同有用的evaluators，请参考： Evaluators Java API 。或者自己简单实现 Evaluator接口。</p> 
  <p>如果你对 Path 没有兴趣，但对 Node 有兴趣，你可以转换遍历器成一个 节点的迭代器，像下面这样：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Node</span> <span class="n">currentNode</span> <span class="p">:</span> <span class="n">FRIENDS_TRAVERSAL</span>
<span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span>
<span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">currentNode</span><span class="o">.</span><span class="n">getProperty</span><span class="p">(</span> <span class="s2">"name"</span> <span class="p">)</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在这种情况下我们使用它来接收名称：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6
7</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">Joe</span>
<span class="n">Sara</span>
<span class="n">Peter</span>
<span class="n">Dirk</span>
<span class="n">Lars</span>
<span class="n">Ed</span>
<span class="n">Lisa</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>Relationships 也同样可以这样，下面是我们如何得到他们</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="k">for</span> <span class="p">(</span> <span class="n">Relationship</span> <span class="n">relationship</span> <span class="p">:</span> <span class="n">FRIENDS_TRAVERSAL</span>
        <span class="o">.</span><span class="n">traverse</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span>
        <span class="o">.</span><span class="n">relationships</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">output</span> <span class="o">+=</span> <span class="n">relationship</span><span class="o">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
<span class="p">}</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>这儿是书写的关系类型，我们将得到他们：</p> 
  <div class="highlight-python">
   <table class="highlighttable">
    <tbody>
     <tr>
      <td class="linenos">
       <div class="linenodiv">
        <pre>1
2
3
4
5
6</pre>
       </div></td>
      <td class="code">
       <div class="highlight">
        <pre><span></span><span class="n">KNOWS</span>
<span class="n">KNOWS</span>
<span class="n">KNOWS</span>
<span class="n">KNOWS</span>
<span class="n">KNOWS</span>
<span class="n">KNOWS</span>
</pre>
       </div> </td>
     </tr>
    </tbody>
   </table>
  </div> 
  <p>在这个范例中的遍历器的源代码下载地址： <a class="reference external" href="https://github.com/neo4j/community/blob/1.8/embedded-examples/src/main/java/org/neo4j/examples/TraversalExample.java">TraversalExample.java</a> 。</p> 
 </div>
</blockquote><h1>第 7 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 8 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 9 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 10 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 11 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 12 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 13 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 14 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 15 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 16 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 17 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 18 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 19 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 20 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 21 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 22 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 23 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 24 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 25 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 26 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 27 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 28 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>第 29 章<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h1><h1>附录 A<a class="headerlink" href="#a" title="Permalink to this headline"></a></h1><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p><h1>附录 B. 常见问题<a class="headerlink" href="#b" title="Permalink to this headline"></a></h1> 
<div class="section" id="neo4j"> 
 <h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
 <p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p> 
</div> 
<div class="section" id="id1"> 
 <h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
 <p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p> 
</div> 
<div class="section" id="id2"> 
 <h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
 <p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p> 
</div> 
<div class="section" id="id3"> 
 <h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
 <p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p> 
</div> 
<div class="section" id="id4"> 
 <h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
 <p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p> 
</div> 
<div class="section" id="id5"> 
 <h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
 <p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p> 
</div> 
<div class="section" id="id6"> 
 <h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
 <p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p> 
</div> 
<div class="section" id="id7"> 
 <h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
 <p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p> 
</div> 
<div class="section" id="id8"> 
 <h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
 <p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p> 
</div> 
<div class="section" id="id9"> 
 <h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
 <p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p> 
</div> 
<div class="section" id="id10"> 
 <h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
 <p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p> 
</div> 
<div class="section" id="id11"> 
 <h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
 <p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p> 
</div> 
<div class="section" id="id12"> 
 <h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
 <p>关于这个话题我们有更深入的探讨。</p> 
</div> 
<div class="section" id="id13"> 
 <h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
 <p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p> 
</div> 
<div class="section" id="ha"> 
 <h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>保持会话。</li> 
  <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
  <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
 </ol> 
</div> 
<div class="section" id="id14"> 
 <h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
 <ol class="arabic simple"> 
  <li>单线程模式。</li> 
  <li>如果不存在，悲观锁在一个普通节点上。</li> 
  <li>如果不存在，乐观创建他，然后再检查。</li> 
 </ol> 
</div> 
<div class="section" id="id15"> 
 <h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
 <p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p> 
</div> 
<div class="section" id="id16"> 
 <h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
 <p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p> 
</div> 
<div class="section" id="id17"> 
 <h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
 <p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p> 
</div> 
<div class="section" id="id18"> 
 <h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
 <p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p> 
</div> 
<div class="section" id="id19"> 
 <h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
 <p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p> 
</div> 
<div class="section" id="id20"> 
 <h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
 <p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p> 
</div> 
<div class="section" id="id21"> 
 <h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
 <p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p> 
</div> 
<div class="section" id="id22"> 
 <h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
 <p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p> 
</div>
<h2>neo4j数据库支持最大多少个节点？最大支持多少条边？<a class="headerlink" href="#neo4j" title="Permalink to this headline"></a></h2> 
<p>目前累积统计它有34.4亿个节点，344亿的关系，和6870亿条属性。</p>
<h2>neo4j数据库支持的最复杂的连接是什么？（比如每个节点都与其他任何一个节点相连）<a class="headerlink" href="#id1" title="Permalink to this headline"></a></h2> 
<p>可以从上面的数字得出理论的极限：它基本上就产生了262144节点和34359607296的关系图。我们从来没有见过这种使用情况。</p>
<h2>在数据库中，读/写性能跟节点/边的数量有关吗？<a class="headerlink" href="#id2" title="Permalink to this headline"></a></h2> 
<p>这个问题意味着两个不同的问题。单次读/写操作不依赖数据库的大小。不管数据库是有10个节点还是有1千万个都一样。 — 然而，有一个事实是如果数据库太大，你的内存可能无法完全缓存住它，因此，你需要频繁的读写磁盘。虽然很多用户没有这样大尺寸的数据库，但有的人却有。如果不巧你的数据库达到了这个尺寸，你可以扩展到多台机器上以减轻缓存压力。</p>
<h2>neo4j数据库支持的读/写并发请求最大数量是多少呢？<a class="headerlink" href="#id3" title="Permalink to this headline"></a></h2> 
<p>在并发请求上面没有任何限制。服务器的并发量更多的是依赖于操作本身的性能（高压写操作，简单读，复杂的遍历等等），以及使用的硬件性能。据粗略估计，在遍历最简单路径时每毫秒可以达到1000次请求。在讨论了指定的用户案例后，我们能得到更好的性能优化方案。</p>
<h2>在数据库集群环境中数据一致性如何保证的呢？<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h2> 
<p>主从复制。从服务器从主服务器拉取数据变化。拉取间隔可以在每个从服务器上进行配置，从毫秒到分钟，根据你自己的需要来定。HA也可以通过从服务器来进行写操作。当发生时，从服务器通过追上主服务器来被写入，然后写入在主从之间完成。其他从服务器做一般处理。</p>
<h2>当在一个数据库中发生更新操作时如何快速更新其他所有服务器呢？<a class="headerlink" href="#id5" title="Permalink to this headline"></a></h2> 
<p>拉取间隔在每个从服务器上面进行配置，从几秒到几分钟不等，根据需求而定。当通过一个从服务器写操作时，从服务器立即在写之前与主服务器进行同步。一般情况下，读写加载不并影响从服务器的同步工作。一个复杂的写操作会给从服务器的文件系统巨大压力，与此同时，从服务器也要求拉取同步数据。实际上，我们不系统这成为一个关注的问题。</p>
<h2>在集群环境中，在不同服务器会出现按比例延迟新增吗？<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h2> 
<p>在集群中从服务器超过10台的规模时，我们能预料到来自从服务器的大量的拉取请求会降低从服务器的性能。在集群中的写操作才会受影响，而读操作依然保持线性缩放。</p>
<h2>支持在线扩展吗？换句话说，如果我们想新加入一台服务器到集群中需要关闭所有服务器吗？<a class="headerlink" href="#id7" title="Permalink to this headline"></a></h2> 
<p>新的从服务器在不用停止或者启动整个集群的情况下可以被加入到一个已经存在的集群中。我们的HA协议会新增入加入的服务器。从服务器也可以简单的通过关闭他们自己来从集群中移除。</p>
<h2>新加入一台服务器到全部同步需要多长时间？<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h2> 
<p>我们推荐在将从服务器加入之前先做一个最近的数据库的快照。一般通过备份来完成。从服务器之需要同步最近的更新，一般情况下只会一点点时间的数据。</p>
<h2>重启需要多久呢？<a class="headerlink" href="#id9" title="Permalink to this headline"></a></h2> 
<p>如果重启，你的意思是关闭集群然后再重启它，这完全依赖与你打字的速度。一般是10秒的样子。Neo4j的缓存不会自动预加载，而操作系统的文件系统缓存不会重置。</p>
<h2>是否有备份恢复机制？<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h2> 
<p>Neo4j 企业版提供了一个在线备份（完整备份和增量备份）功能。</p>
<h2>是否支持跨区集群？跨区集群是否比同区集群性能更低呢？<a class="headerlink" href="#id11" title="Permalink to this headline"></a></h2> 
<p>我们有用户在AWS上面测试了多区域部署的情况。跨地区部署在集群管理的效率和协议同步上有一定影响。集群管理大量的延迟会触发主服务器的频繁重选，拖慢整个集群的速度。在跨区部署支持上面以后还需大量提升。</p>
<h2>是否有任何指定测控策略用于环境建立之类的需求？<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h2> 
<p>关于这个话题我们有更深入的探讨。</p>
<h2>写数据库是线程安全的吗？<a class="headerlink" href="#id13" title="Permalink to this headline"></a></h2> 
<p>不管在单服务模式还是HA模式，数据库在更新之前都通过锁定节点和关系来保证线程安全。</p>
<h2>从HA读数据最好的策略是什么？<a class="headerlink" href="#ha" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>保持会话。</li> 
 <li>在response中发送返回数据，而在独立的请求中移除需要读回的数据。</li> 
 <li>当操作需要时，强制请求从主服务器做一个拉取数据更新操作。</li> 
</ol>
<h2>对于获取（如果不存在则创建）这中需求最好的策略是什么？<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h2> 
<ol class="arabic simple"> 
 <li>单线程模式。</li> 
 <li>如果不存在，悲观锁在一个普通节点上。</li> 
 <li>如果不存在，乐观创建他，然后再检查。</li> 
</ol>
<h2>如何锁定服务？<a class="headerlink" href="#id15" title="Permalink to this headline"></a></h2> 
<p>悲观锁。在读数据时并不要求锁。写操作并不会阻塞读操作。不用任何明确的锁定操作就可以完成读取数据操作是非常重要的。当一个节点或者属性修改或者新增时，写锁定会自动完成，或者也可以通过明确的锁设置。它常被用来提供读取语义和保证必须的数据一致性。</p>
<h2>数据存储占用空间如何？<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h2> 
<p>Neo4j当前并不适合存储 BLOBs/CLOBs。节点，关系和属性并不是保存在磁盘的同一个地方。这个特性将来会进一步介绍。数据库索引怎么样？ Neo4j支持复杂的属性索引。额外的索引功能超过了图本身的索引。Lucene引擎管理独立分页的索引并要求一些空间来存储一个自动索引以及管理私有索引（通过API搜索）。</p>
<h2>我如何进行数据库查询？<a class="headerlink" href="#id17" title="Permalink to this headline"></a></h2> 
<p>核心 API, Traversal API, REST API, Cypher, Gremlin Neo4j使用日志（在数据丢失时可以修复丢失的数据）功能吗？ 在HA集群环境中基于主从服务器之间的写增量来完成。</p>
<h2>我如何提示Neo4j的性能？<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h2> 
<p>采用内存映射存储Neo4j文件，Neo4j缓存策略解释如下： 软索引缓存: 软索引在GC认为需要时会被随时清理。如果应用加载并不高时使用。 弱索引缓存: 不管GC是否找到，都会清理弱索引。如果在读取大量数据或者遍历操作时使用。 强索引缓存: 所有的节点和关系都会保存在内存中，JVM会阻止高加载的操作。比如半分钟的暂停间隔。 更大的堆大小是好的，然而12G或者更大的内存对于GC是不切实际的。如果用从磁盘获取数据做比较，用内存映射文件缓存会提供100倍性能，而用Java堆则会是1000倍。 在主从服务器直接的ACID事务。 在初始从服务器到主服务器的事务同步中，最终从主服务器到其他从服务器。用死锁探测来完成多个从服务器事务并发支持。从一个数据完整性的角度看是完全一致的，但是必须得重多个点考虑。</p>
<h2>独立服务器怎么样？<a class="headerlink" href="#id19" title="Permalink to this headline"></a></h2> 
<p>REST API是完全无状态的，但他也可以通过批量提交来实现大量事务支持。线程池和每个socket的线程：对于独立服务器和HA模式来说，Neo4j采用Jetty来连接线程池。（比如在HA集群中25/每节点）。</p>
<h2>在HA环境中如何使用负载均衡？<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h2> 
<p>通常一个小型服务器扩展被写入后会返回200或404，取决于机器是否是主或从。 扩展被负载均衡服务器用来探测主从服务器设置。只写到从服务器来确保至少在两个地方存在提交事务。</p>
<h2>Neo4j支持那些监控器？<a class="headerlink" href="#id21" title="Permalink to this headline"></a></h2> 
<p>Neo4j目前没有内建的追踪和解释计划。JMX是用于统计和监控的主要接口。线程内容可以用于调试。</p>
<h2>我如何导入数据到Neo4j中？<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h2> 
<p>Neo4j批量插入用于初始化一个数据库。在批量插入后，存储的内容可以用与嵌入模式或者HA环境。直接跟传统SQL服务器直接的数据交换目前没有官方支持。</p>